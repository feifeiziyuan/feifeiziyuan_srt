1
00:00:00,266 --> 00:00:03,333
让我们退后一步，眯着眼睛看目前为止的代码
let's step back and squint at the code we have so far

2
00:00:03,933 --> 00:00:06,100
查看此客户端服务器交互
looking at this client server interaction

3
00:00:06,100 --> 00:00:08,000
我们看到两种风格的代码
we see two flavors of code

4
00:00:08,300 --> 00:00:10,166
所有消息通用的代码
code that's common to all messages

5
00:00:10,166 --> 00:00:12,166
和特定于消息的代码
and code that's specific to a message

6
00:00:12,533 --> 00:00:14,166
在客户端界面方面
in terms of the client interface

7
00:00:14,166 --> 00:00:16,566
所有三个函数都向服务器发送消息
all three functions send a message to the server

8
00:00:16,566 --> 00:00:18,500
然后等待收到回复
and then wait to receive a response

9
00:00:18,866 --> 00:00:21,500
接收块一开始是特定的
the receive block at first appear specific

10
00:00:21,733 --> 00:00:23,766
但是这些变量名是任意的
but these variable names are arbitrary

11
00:00:23,933 --> 00:00:25,700
所以我们可以使这些块通用
so we can make these blocks generic

12
00:00:25,700 --> 00:00:28,500
只需将变量重命名为响应
simply by renaming the variable to response

13
00:00:28,833 --> 00:00:29,366
现在
now the

14
00:00:29,366 --> 00:00:30,800
唯一特定于每个的东西
only thing that specific to each

15
00:00:30,800 --> 00:00:32,400
函数是实际的消息
function is the actual message

16
00:00:32,400 --> 00:00:33,200
那是发送的
that's sent

17
00:00:33,800 --> 00:00:34,166
怎么办
now what

18
00:00:34,166 --> 00:00:35,800
关于监听循环中的代码
about the code in the listen loop that

19
00:00:35,800 --> 00:00:37,900
在服务器进程中运行良好
runs in the server process well

20
00:00:37,900 --> 00:00:40,600
需要注意的一件事是所有预期的消息都有
one thing to notice is that all expected messages have

21
00:00:40,600 --> 00:00:42,233
发件人作为第一个元素
sender as the first element

22
00:00:43,000 --> 00:00:46,000
每个子句也以做同样的两件事结束
also each clause ends by doing the same two things

23
00:00:46,233 --> 00:00:49,033
他们将响应消息发送回发件人
they send a response message back to the sender

24
00:00:49,200 --> 00:00:51,566
然后与状态递归循环
and then recursively loop with the state

25
00:00:51,566 --> 00:00:53,533
在处理下一条消息时使用
to be used when handling the next message

26
00:00:54,133 --> 00:00:55,766
在创建承诺的情况下
in the case of creating a pledge

27
00:00:55,766 --> 00:00:57,466
响应包括 id
the response includes id

28
00:00:57,533 --> 00:00:59,900
状态是更新的现金
and the state is the updated cash

29
00:01:00,366 --> 00:01:02,500
在获得最近的承诺的情况下
in the case of getting recent pledges

30
00:01:02,533 --> 00:01:04,200
响应包括状态
the response includes the state

31
00:01:04,466 --> 00:01:05,966
这是承诺清单
which is the list of pledges

32
00:01:06,166 --> 00:01:07,600
并且由于状态没有改变
and since the state didn't change

33
00:01:07,900 --> 00:01:10,533
循环的下一次迭代使用当前状态
the next iteration of the loop uses the current state

34
00:01:11,200 --> 00:01:13,500
并且在获得总质押的情况下
and in the case of getting the total pledge

35
00:01:13,500 --> 00:01:15,633
响应包括总金额
the response includes the total amount

36
00:01:15,633 --> 00:01:17,266
并且状态不变
and the state is unchanged

37
00:01:17,633 --> 00:01:18,866
现在你可以想象
now you can imagine that

38
00:01:18,900 --> 00:01:20,600
每次你介绍一个新消息
every time you introduce a new message

39
00:01:20,600 --> 00:01:23,866
你需要写更多的这个泛型来处理
you'll need to write more of this generic to handle

40
00:01:24,000 --> 00:01:26,766
客户端服务器交互的底层细节
the low level details of client server interaction

41
00:01:27,300 --> 00:01:29,300
但肯定长生不老药不会让我们这样做
but surely elixir wouldn't make us do that

42
00:01:29,866 --> 00:01:32,333
像这样编写大量的服务器进程是
writing spadeful server processes like this is

43
00:01:32,333 --> 00:01:34,633
如此普遍以至于实际上有一个抽象
so common that there's actually an abstraction

44
00:01:35,033 --> 00:01:38,433
gen server 代表通用服务器进程
gen server which stands for generic server process

45
00:01:38,500 --> 00:01:40,333
封装通用代码
encapsulates the generic code

46
00:01:40,333 --> 00:01:43,033
这对于 spadeful 服务器进程很常见
that's common to spadeful server processes

47
00:01:43,200 --> 00:01:44,100
这样
and that way

48
00:01:44,166 --> 00:01:47,233
我们可以专注于编写应用程序特定的代码
we can focus on writing the application specific code

49
00:01:47,766 --> 00:01:49,700
所以我们可以转换我们的质押服务器
so we could convert our pledge server

50
00:01:49,700 --> 00:01:51,733
此时直接到 gen 服务器
straight to a gen server at this point

51
00:01:51,866 --> 00:01:53,366
但如果我们实现这一飞跃
but if we make that leap

52
00:01:53,500 --> 00:01:55,333
gen server 将拍摄魔法
gen server is going to film magical

53
00:01:55,566 --> 00:01:57,033
可能太神奇了
probably too magical

54
00:01:57,300 --> 00:01:58,033
是的
yeah instead

55
00:01:58,033 --> 00:01:59,300
我们想重构我们的
we want to refactor our

56
00:01:59,300 --> 00:02:01,366
代服务器风格的代码
code towards the gen server style

57
00:02:01,466 --> 00:02:04,233
到最后，一个 gen server 就会崩溃
and by the end a gen server will just sort of fall out

58
00:02:04,400 --> 00:02:05,266
你会有更好的
and you'll have a better

59
00:02:05,366 --> 00:02:07,133
了解它在后台是如何工作的
understanding of how it works under the hood

60
00:02:07,833 --> 00:02:09,866
让我们从删除重复开始
let's start by removing the duplication

61
00:02:09,866 --> 00:02:11,933
在这些客户端接口函数中
in these client interface functions

62
00:02:12,266 --> 00:02:14,866
是的，我们将尝试帮助我们封装的方法
yeah we'll try to help our method that encapsulates to

63
00:02:14,866 --> 00:02:16,933
在这些内部发送和接收步骤
send and receive steps inside of these

64
00:02:17,433 --> 00:02:19,100
所以我要继续复制其中一个
so I'm just going to go ahead and copy one of these

65
00:02:19,100 --> 00:02:20,000
随身携带
and take it with us

66
00:02:20,566 --> 00:02:22,266
我们要在这里找到一个函数
we're going to find a function down here

67
00:02:22,833 --> 00:02:26,266
被叫调用认为远程过程调用
called call think remote procedure call

68
00:02:26,266 --> 00:02:27,800
这是一个同步请求
it's a synchronous request

69
00:02:27,866 --> 00:02:29,600
它向服务器发送消息
it sends a message to the server

70
00:02:29,600 --> 00:02:31,400
然后等待我们的回应
and then waits for our response

71
00:02:31,433 --> 00:02:34,833
并且性别将同步请求称为调用
and gender refers to synchronous requests as calls

72
00:02:34,866 --> 00:02:36,033
所以我们会效仿
so we'll follow suit

73
00:02:36,433 --> 00:02:37,900
然后粘贴在那件外套上
then just paste in that coat

74
00:02:38,333 --> 00:02:39,966
现在让它更通用
and let's make it more generic now

75
00:02:39,966 --> 00:02:41,700
所以电话需要接听
so call is going to need to take a

76
00:02:41,700 --> 00:02:43,200
pid和一条消息
pid and a message

77
00:02:43,566 --> 00:02:45,233
我们将发送给那个pid
and we're going to send to that pid

78
00:02:46,933 --> 00:02:49,500
消息，以便我们可以删除此特定消息
the message so we can remove this specific message

79
00:02:49,500 --> 00:02:51,500
它只是传递进来的任何消息
it's just going to be whatever message gets passed in

80
00:02:51,766 --> 00:02:53,800
并且self必须永远是第一个
and self must always be the first

81
00:02:53,800 --> 00:02:54,766
消息元素
element of the message

82
00:02:54,766 --> 00:02:56,233
这个功能负责
and this function takes care of

83
00:02:56,233 --> 00:02:58,066
确保这总是正确的
making sure that's always true

84
00:02:58,400 --> 00:02:59,566
然后在接收块中
and then in the receive block

85
00:02:59,566 --> 00:03:01,366
我们将把响应标记为
we're going to tag the response as

86
00:03:01,366 --> 00:03:03,066
响应是一个原子
response which is an atom

87
00:03:03,133 --> 00:03:04,033
然后我们将绑定
and then we're just going to bind

88
00:03:04,033 --> 00:03:05,566
对通用变量的响应
the response to a generic variable

89
00:03:05,566 --> 00:03:07,266
我们只是打电话给响应
we're just going to call response

90
00:03:09,100 --> 00:03:09,800
所以现在让我们改变
so now let's change

91
00:03:09,800 --> 00:03:11,600
要使用的客户端接口函数
the client interface functions to use

92
00:03:11,600 --> 00:03:13,133
我们的新调用函数
our new call function

93
00:03:13,466 --> 00:03:15,700
所以我们将从删除此接收行开始
so we'll start by removing this receive line

94
00:03:15,766 --> 00:03:17,566
我将在所有功能中删除它
I'll just remove that in all the functions

95
00:03:17,566 --> 00:03:18,966
因为 call 为我们做到了
because call does that for us

96
00:03:20,300 --> 00:03:21,500
然后而不是打电话
and then instead of calling

97
00:03:21,500 --> 00:03:22,766
cind 在这里我们想打电话
cind right here we want to call

98
00:03:22,766 --> 00:03:24,300
打电话，我们会通过名字
call and we'll pass it at name

99
00:03:24,300 --> 00:03:26,533
这就是我们服务器进程的坑
that's the pit of our server process

100
00:03:26,600 --> 00:03:27,900
然后就消息而言
and then in terms of the message

101
00:03:27,900 --> 00:03:29,000
我们不需要包括
we don't need to include

102
00:03:29,000 --> 00:03:30,500
self 是第一个元素，因为
self is the first element because the

103
00:03:30,500 --> 00:03:31,933
调用函数负责处理
call function takes care of that

104
00:03:32,533 --> 00:03:33,966
好的，这条消息是一个工具
okay and this message is a tootle

105
00:03:33,966 --> 00:03:35,533
所以我们周围有卷发
so we've got curlies around it

106
00:03:35,533 --> 00:03:37,400
但我们不需要围绕这些卷曲
but we don't need curlies around these

107
00:03:37,400 --> 00:03:38,500
因为他们只是亚当斯
because they're just adams

108
00:03:38,500 --> 00:03:39,466
所以我会删除那些
so I'll remove those

109
00:03:40,933 --> 00:03:42,666
现在如果我们往下看接收到的块
now if we look down in the received block of

110
00:03:42,666 --> 00:03:43,700
后循环在这里
mizzen loop down here

111
00:03:43,700 --> 00:03:44,600
你注意到
you notice that

112
00:03:44,866 --> 00:03:46,333
这个伟大的承诺信息
this great pledge message

113
00:03:46,533 --> 00:03:48,933
好吧，它不是卷曲的，但这里的这个是
well it's not in curly's but this one up here is

114
00:03:49,500 --> 00:03:51,700
所以我们需要确保将它嵌套在 curly 中
so we need to make sure to nest this in curly's

115
00:03:51,700 --> 00:03:52,500
就在这里
right down here

116
00:03:53,766 --> 00:03:55,100
把它保存起来，如果我们运行它
save that away and if we run it

117
00:03:55,433 --> 00:03:56,833
好吧，它就像以前一样工作
well it works just like before

118
00:03:56,866 --> 00:03:58,466
但现在我们已经删除了重复项
but now we've removed the duplication

119
00:03:58,466 --> 00:04:00,133
在那些爬升的接口函数中
in those climbed interface functions

120
00:04:00,900 --> 00:04:02,133
现在在监听循环中
now down in the listen loop

121
00:04:02,133 --> 00:04:03,366
我们想分开
we want to separate the

122
00:04:03,366 --> 00:04:06,333
来自应用程序特定代码的公共代码
common code from the application specific code

123
00:04:06,600 --> 00:04:07,600
并做到这一点
and to do that

124
00:04:07,733 --> 00:04:10,000
让我们在
let's add a generic clause to the

125
00:04:10,000 --> 00:04:11,633
接收循环的顶部
top of the received loop

126
00:04:11,633 --> 00:04:15,233
因为所有预期的消息都具有相同的基本模式
since all expected messages have the same basic pattern

127
00:04:15,533 --> 00:04:16,733
是的，他们从发件人开始
yeah they start with a sender

128
00:04:16,733 --> 00:04:18,266
然后是消息的其余部分
and then there's the rest of the message

129
00:04:19,466 --> 00:04:22,100
每个爪子都以做同样的两件事而告终
in each claws ends by doing the same two things

130
00:04:22,566 --> 00:04:24,500
他们向发件人发送响应
they send a response to the sender

131
00:04:24,866 --> 00:04:26,866
所以它发送发件人
so it send sender

132
00:04:27,600 --> 00:04:28,900
消息看起来像这样
and the message looks like this

133
00:04:29,100 --> 00:04:31,300
回应，然后有一些回应
response and then there's some response

134
00:04:31,300 --> 00:04:32,300
与之相关的
associated with that

135
00:04:32,933 --> 00:04:35,133
然后他们递归地调用监听循环
and then they recursively call listen loop

136
00:04:35,933 --> 00:04:36,866
与国家
with the state

137
00:04:36,866 --> 00:04:39,166
在循环的下一次迭代中使用
to be used in the next iteration of the loop

138
00:04:39,766 --> 00:04:41,966
每个子句还具有特定于消息的代码
each clause also has message specific code

139
00:04:41,966 --> 00:04:43,366
所以这里有一些特定的消息
so here's some message specific

140
00:04:43,366 --> 00:04:44,800
创建承诺的代码
code for creating a pledge

141
00:04:45,333 --> 00:04:47,666
总承诺在那里进行计算
total pledges does a computation right there

142
00:04:48,066 --> 00:04:50,366
我们不希望接收循环中的任何代码
and we don't want any of that code in the receive loop

143
00:04:50,366 --> 00:04:52,000
我们希望循环是通用的
we want the loop to be generic

144
00:04:52,433 --> 00:04:53,400
没问题
well that's no problem

145
00:04:53,700 --> 00:04:55,900
我们知道有条件地运行代码的方法
we know a way to conditionally run code

146
00:04:55,900 --> 00:04:57,466
基于模式匹配
based on pattern matches

147
00:04:57,533 --> 00:04:59,633
我们可以使用多子句函数
we can use multi clause functions

148
00:04:59,900 --> 00:05:01,733
是的，我们会把它放在这个监听循环下面
yeah we'll put it below this listen loop

149
00:05:03,600 --> 00:05:06,733
我们将函数命名为处理下划线调用
and we'll name the functions handle underscore call

150
00:05:06,833 --> 00:05:08,833
因为他们处理同步调用
because they handle the synchronous call

151
00:05:08,833 --> 00:05:10,133
我们从客户那里得到
we got from the client

152
00:05:10,400 --> 00:05:12,900
然后他们会接受两个参数的消息
and then they're going to take two arguments a message

153
00:05:13,566 --> 00:05:14,433
和国家
and the state

154
00:05:14,833 --> 00:05:15,700
我们需要一个
and we're going to need a

155
00:05:15,700 --> 00:05:18,733
对于每个特定的消息，这样的函数子句
function clause like this for every specific message

156
00:05:18,933 --> 00:05:21,933
所以让我们从底部开始，一路向上
so let's start from the bottom and work our way up 1st

157
00:05:21,933 --> 00:05:24,766
我们需要一个匹配的句柄调用函数子句
we need a handle call function clause that matches

158
00:05:24,833 --> 00:05:25,933
认捐总额
total pledges

159
00:05:26,433 --> 00:05:27,733
所以这将是信息
so that's going to be the message

160
00:05:28,333 --> 00:05:29,433
我就贴在那里
I'll just paste that there

161
00:05:29,966 --> 00:05:32,033
然后我们将获取消息特定代码
and then we'll take the message specific code

162
00:05:34,100 --> 00:05:36,000
并将其粘贴为函数的主体
and paste it in as the body of the function

163
00:05:36,433 --> 00:05:38,266
现在这个函数返回总数
and now this function returns the total

164
00:05:38,266 --> 00:05:40,100
这是我们要发送的响应
which is the response that we want to send

165
00:05:40,100 --> 00:05:41,600
回到客户端进程
back to the client process

166
00:05:42,133 --> 00:05:44,900
所以现在如果我们回到我们的通用爪子这里
so now if we go back up into our generic claws here

167
00:05:45,433 --> 00:05:47,533
我们需要做的是调用句柄调用
what we need to do is invoke handle call

168
00:05:49,400 --> 00:05:51,366
将当前状态的消息传递给它
pass it the message in the current state

169
00:05:51,866 --> 00:05:52,866
它会回来的
it's going to return

170
00:05:52,866 --> 00:05:54,800
我们应该发回给客户的东西
the thing that we should send back to the client

171
00:05:54,800 --> 00:05:55,800
所以我们要绑定它
so we're going to bind that

172
00:05:55,800 --> 00:05:57,566
到一个称为响应的变量
to a variable called response

173
00:05:57,666 --> 00:05:59,600
然后我们在消息中包含响应
and then we include the response in the message

174
00:05:59,600 --> 00:06:00,400
在那里
right there

175
00:06:00,700 --> 00:06:03,266
现在你注意到我们刚刚传递了这部分信息
now you notice we just passed this part of the message

176
00:06:03,266 --> 00:06:03,900
进入处理调用
into handle call

177
00:06:03,900 --> 00:06:05,566
我们不必传入发件人
we didn't have to pass the sender in

178
00:06:05,766 --> 00:06:07,666
因为发件人是在线使用的
because the sender is used on the line

179
00:06:07,766 --> 00:06:10,266
处理呼叫后发送回发件人
after handle call to send back to the sender

180
00:06:10,333 --> 00:06:12,900
所以所有处理呼叫需求都是消息的这一部分
so all handle call needs is this part of the message

181
00:06:13,466 --> 00:06:16,133
所以现在我们可以删除总认捐的这个条款
so now we can remove this clause for total pledges

182
00:06:16,400 --> 00:06:18,666
因为通用子句负责
because the generic clause takes care of that

183
00:06:19,500 --> 00:06:21,233
接下来我们需要一个函数子句
next we need a function clause that

184
00:06:21,233 --> 00:06:23,533
匹配最近的承诺信息
matches the recent pledges message

185
00:06:24,033 --> 00:06:25,400
好的，我们将复制该消息
all right we'll copy that message

186
00:06:27,500 --> 00:06:29,433
在句柄调用函数子句中
at a handle call function clause

187
00:06:29,433 --> 00:06:30,633
这将是信息
that's going to be the message

188
00:06:31,000 --> 00:06:31,600
也必须采取
also has to take the

189
00:06:31,600 --> 00:06:32,400
状态
state

190
00:06:32,800 --> 00:06:34,500
那么在这种情况下的反应是什么
so what's the response in this case

191
00:06:34,500 --> 00:06:36,533
客户想要最近的承诺
well the client wants the recent pledges

192
00:06:36,533 --> 00:06:38,633
所以我们只返回整个状态
so we just return the entire state

193
00:06:38,666 --> 00:06:40,766
这就是我们想要发回给客户端的响应
that's the response we want to send back to the client

194
00:06:41,100 --> 00:06:43,533
现在我们可以移除最近的承诺爪
and now we can remove the recent pledges claws

195
00:06:43,533 --> 00:06:45,100
因为我们的通用爪子在顶部
because our generic claws at the top

196
00:06:45,100 --> 00:06:46,166
会处理的
is going to take care of that

197
00:06:46,933 --> 00:06:47,500
然后最后
and then last

198
00:06:47,500 --> 00:06:49,000
但同样重要的是，我们需要一个
but not least we need a

199
00:06:49,000 --> 00:06:51,433
匹配 create 的第三个函数子句
third function clause that matches the create

200
00:06:51,433 --> 00:06:52,400
承诺信息
pledge message

201
00:06:53,733 --> 00:06:54,533
好的
all right

202
00:06:55,633 --> 00:06:56,466
处理呼叫
handle call

203
00:06:57,400 --> 00:06:58,366
有消息
there's the message

204
00:06:58,533 --> 00:06:59,400
有状态
there's the state

205
00:06:59,833 --> 00:07:01,600
然后我要回去接收消息
then I'm going to go back up and get the message

206
00:07:01,600 --> 00:07:02,433
具体代码
specific code

207
00:07:02,433 --> 00:07:04,766
这是发送前的一切
it's everything before the send

208
00:07:05,033 --> 00:07:06,066
所以我就复制一下
so I'll just copy that

209
00:07:11,333 --> 00:07:13,366
好的，那么在这种情况下的反应是什么
okay so what's the response in this case

210
00:07:13,500 --> 00:07:15,433
好吧，我们想返回这个 id
well we want to return this id

211
00:07:15,733 --> 00:07:16,866
那个id是绑定的
that id is bound

212
00:07:16,866 --> 00:07:19,400
由于调用了这个罪的誓言来服务
as a result of calling this sin pledge to service

213
00:07:19,400 --> 00:07:20,700
所以它是任何 id
so it's whatever id

214
00:07:20,866 --> 00:07:22,633
发回给我们的外部服务
the external service sent back to us

215
00:07:23,100 --> 00:07:25,033
所以我们把它放在函数的最后一行
so we'll just put that on the last line the function

216
00:07:25,133 --> 00:07:26,366
然后它会被退回
and then it'll get returned

217
00:07:26,666 --> 00:07:27,633
然后那个id
and then that id

218
00:07:27,866 --> 00:07:29,800
将是发回的响应的一部分
will be part of the response that sent back

219
00:07:29,800 --> 00:07:30,600
给客户
to the client

220
00:07:31,000 --> 00:07:34,033
然后我们可以在接收到的循环中删除该子句
and then we can remove that clause in our received loop

221
00:07:34,600 --> 00:07:36,366
因为我们的通用条款正在处理那个
because our generic clause is taking care of that one

222
00:07:36,366 --> 00:07:37,166
现在也是
now too

223
00:07:39,633 --> 00:07:40,900
好的，让我们运行它
okay so let's run it

224
00:07:41,766 --> 00:07:43,800
好吧，这不太对
well that's not quite right

225
00:07:43,933 --> 00:07:44,500
我们看
we see

226
00:07:44,500 --> 00:07:47,866
承诺是在外部服务中创建的
that the pledges were created in the external service

227
00:07:48,066 --> 00:07:51,066
但是我们的现金是空的，我们的总数为零
but our cash is empty and our total is zero

228
00:07:51,566 --> 00:07:53,066
那是因为创造
and that's because create

229
00:07:53,100 --> 00:07:55,900
质押改变当前状态
pledge transforms the current state

230
00:07:56,066 --> 00:07:57,300
进入新状态
into a new state

231
00:07:57,866 --> 00:07:59,333
但一般条款
but the generic clause

232
00:07:59,333 --> 00:08:01,700
总是以当前状态重复出现
is always recurring with the current state

233
00:08:02,066 --> 00:08:04,666
是的，如果句柄调用更新状态
yeah if handle call updates the state

234
00:08:04,866 --> 00:08:06,100
传递给它
that gets passed to it

235
00:08:06,233 --> 00:08:08,833
然后我们需要用那个新状态重复
then we need to recurs with that new state

236
00:08:09,400 --> 00:08:10,200
所以我们会改变
so we'll change

237
00:08:10,200 --> 00:08:13,433
处理调用以始终在元组中返回两件事
handle call to always return two things in a tuple

238
00:08:13,766 --> 00:08:14,133
首先
the first

239
00:08:14,133 --> 00:08:16,000
事情将是我们想要发回的响应
thing will be the response that we want to send back

240
00:08:16,000 --> 00:08:16,866
给客户
to the client

241
00:08:16,866 --> 00:08:17,633
第二个
and the second

242
00:08:17,633 --> 00:08:18,333
事情会是
thing will be

243
00:08:18,333 --> 00:08:20,233
我们想要重现的新状态
the new state that we want to recurs with

244
00:08:21,166 --> 00:08:23,900
所以我们需要将这里的状态更改为新状态
so we need to change state here to new state

245
00:08:24,500 --> 00:08:25,300
现在让它工作
now for that to work

246
00:08:25,300 --> 00:08:26,500
我们需要改变我们的功能
we need to change our function

247
00:08:26,500 --> 00:08:28,200
爪子在这里返回
claws down here to return

248
00:08:28,300 --> 00:08:30,566
两件事第一件事就是id
two things the first thing is going to be the id

249
00:08:30,566 --> 00:08:32,733
这就是我们想要发回给客户端的响应
that's the response we want to send back to the client

250
00:08:33,033 --> 00:08:34,866
但我们也想返回新的状态
but we also want to return the new state

251
00:08:35,666 --> 00:08:36,933
所以我们在那里返回一个元组
so we're returning a tuple there

252
00:08:37,400 --> 00:08:39,900
这样当我们将状态转换为新状态时
that way when we transform the state to the new state

253
00:08:40,066 --> 00:08:41,166
我们把它还回来
we return that back

254
00:08:41,800 --> 00:08:42,533
以同样的方式
in the same way

255
00:08:42,533 --> 00:08:44,666
我们需要在
we need to return a two element tuple in the

256
00:08:44,666 --> 00:08:45,566
其他句柄调用
other handle call

257
00:08:45,566 --> 00:08:46,733
功能从句
function clauses

258
00:08:47,400 --> 00:08:48,800
所以对于总认捐
so for total pledged

259
00:08:48,900 --> 00:08:51,166
我们想把总数发回给客户
we want to send back the total to the client

260
00:08:51,300 --> 00:08:53,466
然后我们将与国家重演
and then we were going to recurs with the state

261
00:08:53,466 --> 00:08:54,700
因为我们没有改变状态
because we haven't changed the state

262
00:08:54,800 --> 00:08:57,033
我们只是要返回现有的状态
we're just going to return the existing state

263
00:08:57,566 --> 00:08:59,200
然后是最近的承诺
and then for recent pledges

264
00:08:59,266 --> 00:09:00,333
我们想回来
we want to return

265
00:09:00,466 --> 00:09:01,766
这个状态给客户端
this state to the client

266
00:09:01,766 --> 00:09:03,700
因为国家有所有的承诺和
because the state has all the pledges and

267
00:09:03,700 --> 00:09:05,533
他们要求所有最近的承诺
they're asking for all the recent pledges

268
00:09:05,566 --> 00:09:07,466
我们也想用那个状态重新诅咒
and we also want to re curse with that state

269
00:09:07,733 --> 00:09:08,766
所以这个元组有
so this tuple has

270
00:09:08,900 --> 00:09:10,366
两个都是状态的元素
two elements that are both state

271
00:09:11,400 --> 00:09:12,533
保存并运行它
save it away and run it

272
00:09:12,933 --> 00:09:14,233
嘿，现在可以了
hey and that now works

273
00:09:15,266 --> 00:09:17,433
现在我们注释掉了
now we commented out the line that has

274
00:09:17,433 --> 00:09:19,000
我们意想不到的信息
our unexpected message

275
00:09:19,033 --> 00:09:21,933
如果我们现在把它放回去并运行它
if we put that back in now and run it

276
00:09:22,866 --> 00:09:24,200
好吧，我们得到一个错误
well we get an error

277
00:09:24,700 --> 00:09:27,666
是的，它说没有功能爪匹配
right it says there's no function claws matching

278
00:09:28,000 --> 00:09:30,366
它正在尝试调用句柄调用函数
it's trying to call the handle call function

279
00:09:30,500 --> 00:09:31,566
用锤子时间
with hammer time

280
00:09:32,066 --> 00:09:34,700
那是因为这条消息将匹配我们的
well that's because this message is going to match our

281
00:09:34,700 --> 00:09:36,200
通用消息爪
generic message claws

282
00:09:36,200 --> 00:09:39,333
它认为这是发件人，这是消息
it thinks this is the sender and this is the message

283
00:09:40,100 --> 00:09:42,700
所以如果我们再看看我们的通用爪子就在这里
so up here if we look at our generic claws again

284
00:09:43,233 --> 00:09:46,833
所以这个模式将匹配停止
so this pattern is going to match stop

285
00:09:47,266 --> 00:09:48,033
锤击时间
hammer time

286
00:09:48,033 --> 00:09:49,766
这将尝试调用句柄调用
and this is going to try to call handle call

287
00:09:49,766 --> 00:09:50,600
用锤子时间
with hammer time

288
00:09:50,600 --> 00:09:51,800
这就是为什么我们得到那种空气
which is why we get that air

289
00:09:51,800 --> 00:09:54,966
没有与该消息匹配的功能爪
there's no function claws that matches that message

290
00:09:55,533 --> 00:09:58,033
所以要解决这个问题，我们将添加一个保护爪
so to fix this we're going to add a guard claws

291
00:09:58,033 --> 00:09:59,333
这个模式就在这里
to this pattern right here

292
00:09:59,366 --> 00:10:02,133
我要说 pid sender 是什么时候
I'm going to say when is pid sender

293
00:10:02,466 --> 00:10:05,033
所以这就是说这应该只匹配
so that's saying this should only match

294
00:10:05,200 --> 00:10:08,066
如果这个元组的第一个元素中有什么
if whatever is in the first element of this tuple

295
00:10:08,233 --> 00:10:11,966
是一个pid，我们使用愚蠢的函数并传入sender
is a pid we use the stupid function and pass in sender

296
00:10:12,000 --> 00:10:13,366
这样它就不会匹配
that way it won't match

297
00:10:13,466 --> 00:10:16,366
停止我们意外消息中的原子
stop the atom that we have in our unexpected message

298
00:10:16,433 --> 00:10:18,266
只有当这是一个 pid 时才会匹配
it will only match if this is a pid

299
00:10:19,700 --> 00:10:20,766
现在可以了
and now that works

300
00:10:21,633 --> 00:10:23,500
现在您的应用中可能会出现一些情况
now there may be situations in your app

301
00:10:23,500 --> 00:10:26,166
您要向服务器进程发送消息的位置
where you want to send a message to a server process

302
00:10:26,166 --> 00:10:27,933
但您无需等待回复
but you don't need to wait for a reply

303
00:10:28,466 --> 00:10:29,900
基本上你想开火
basically you want to fire off

304
00:10:29,900 --> 00:10:32,466
向服务器发送消息，然后忘记它
a message to the server and then forget about it

305
00:10:32,966 --> 00:10:35,066
所以现在让我们看一个简单的例子
so let's look at a simple example for now

306
00:10:35,333 --> 00:10:37,533
稍后我们将看一个更复杂的示例
later we'll look at a more involved example

307
00:10:37,966 --> 00:10:40,766
假设我们想要能够清除的选项
let's suppose we want the option of being able to clear

308
00:10:40,766 --> 00:10:43,933
拿出现金，这样我们就可以像一个清晰的函数一样调用
out the cash so we could call like a clear function

309
00:10:45,200 --> 00:10:47,200
是的，假设我们有一个质押服务器
yeah let's assume we have a pledge server

310
00:10:47,600 --> 00:10:48,833
像这样清除功能
clear function like that

311
00:10:49,300 --> 00:10:50,533
所以让我们继续执行它
so let's go ahead and implement that

312
00:10:50,533 --> 00:10:51,733
客户端接口函数
client interface function

313
00:10:51,733 --> 00:10:52,966
我会把它放在这里
I'll put it right up here

314
00:10:57,666 --> 00:10:59,200
所以它需要做的就是发送
so all it needs to do is send

315
00:10:59,666 --> 00:11:02,300
到我们的服务器处理消息清除
to our server process the message clear

316
00:11:02,866 --> 00:11:05,366
与其他客户端接口功能相比
and in contrast to the other client interface functions

317
00:11:05,400 --> 00:11:06,633
clear 是同步的
clear is a synchronous

318
00:11:06,633 --> 00:11:08,933
它只是向服务器发送一条消息，然后
it just fires off a message to the server and

319
00:11:09,000 --> 00:11:11,200
因为它不需要等待响应
since it doesn't need to wait for a response

320
00:11:11,300 --> 00:11:12,933
它几乎立即返回
it returns almost immediately

321
00:11:13,366 --> 00:11:15,366
现在你可以想象一个场景
now you can imagine a scenario where you have

322
00:11:15,366 --> 00:11:16,066
超过一个
more than one

323
00:11:16,066 --> 00:11:18,266
简单地发送这样的消息的函数
function that simply sends a message like this

324
00:11:18,466 --> 00:11:21,466
所以就像我们写了一个调用帮助函数一样
so in the same way that we wrote a call helper function

325
00:11:21,566 --> 00:11:23,600
封装同步请求
that encapsulates synchronous requests

326
00:11:23,933 --> 00:11:24,500
相似地
similarly

327
00:11:24,500 --> 00:11:26,666
我们可以编写一个辅助函数来封装
we can write a helper function that encapsulates

328
00:11:26,666 --> 00:11:27,866
同步请求
a synchronous request

329
00:11:28,100 --> 00:11:29,066
只是为了对称
just for symmetry

330
00:11:29,933 --> 00:11:31,033
所以我要在这里发表评论
so I'm going to put a comment here

331
00:11:31,033 --> 00:11:32,400
这是辅助功能
here are helper functions

332
00:11:33,866 --> 00:11:35,433
并在电话下方
and down below call

333
00:11:36,200 --> 00:11:37,533
将定义一个新函数
will define a new function

334
00:11:37,833 --> 00:11:39,333
我要称之为演员表
I'm going to call it cast

335
00:11:39,766 --> 00:11:42,233
想想这就像把信息扔给风
think of this like casting the message to the wind

336
00:11:42,366 --> 00:11:43,966
这是一个e同步请求
it's an e synchronous request

337
00:11:43,966 --> 00:11:45,500
它向服务器发送消息
it sends a message to the server

338
00:11:45,533 --> 00:11:47,500
并且不期望得到回应
and doesn't expect a response

339
00:11:47,566 --> 00:11:49,800
所以它需要一个pid和一个消息
so it's going to take a pid and a message

340
00:11:50,966 --> 00:11:52,100
这将发送
and this is going to send

341
00:11:52,833 --> 00:11:54,200
给那个坑的信息
the message to that pit

342
00:11:55,200 --> 00:11:58,233
然后我们可以将 clear 更改为而不是调用 send
then we can change clear to instead of calling send

343
00:11:58,233 --> 00:12:00,200
它只会调用 cast
it's just going to call cast

344
00:12:00,766 --> 00:12:02,200
现在这并没有给我们带来多少好处
now that didn't buy us much

345
00:12:02,200 --> 00:12:04,566
除了一些更名和一些墓地
other than some renaming and some cemetery

346
00:12:04,600 --> 00:12:06,233
但和我们待一会儿
but hang with us for a minute

347
00:12:06,766 --> 00:12:08,100
然后在我们收到的块中
then in our received block

348
00:12:08,100 --> 00:12:09,766
我们可以处理那个明确的信息
we can handle that clear message

349
00:12:09,766 --> 00:12:10,733
我会把它放在这里
I'll put it right here

350
00:12:11,500 --> 00:12:12,300
清除
clear

351
00:12:12,633 --> 00:12:13,700
我们需要做的就是
and all we need to do is

352
00:12:13,700 --> 00:12:15,433
将状态重置为空列表
reset the state to an empty list

353
00:12:15,433 --> 00:12:16,366
所以新的状态
so the new state

354
00:12:16,900 --> 00:12:18,533
将是一个像那样的空列表
is just going to be an empty list like that

355
00:12:18,700 --> 00:12:20,800
然后我们需要以那个新状态递归
and then we need to recurs with that new state

356
00:12:21,166 --> 00:12:23,966
客户不期望响应，所以我们不发送
the client doesn't expect a response so we don't send

357
00:12:24,033 --> 00:12:24,833
什么回来
anything back

358
00:12:25,133 --> 00:12:26,866
所以如果我们说完然后运行它
so if we say that away and we run it

359
00:12:27,133 --> 00:12:27,966
虽然它有效
while it works

360
00:12:27,966 --> 00:12:29,300
现在我们最近的承诺
now our recent pledges

361
00:12:29,333 --> 00:12:31,466
只包括恩典，因为我们清除了它
just includes grace because we cleared it

362
00:12:31,533 --> 00:12:32,600
其他一切都消失了
and everything else was gone

363
00:12:32,600 --> 00:12:34,933
然后我们为最近的承诺增添了恩典
and then we added grace to the recent pledges

364
00:12:35,766 --> 00:12:37,700
但假设你有不止一个
but suppose you have more than one of these

365
00:12:37,700 --> 00:12:39,800
并且您想要一种通用的方式来处理
and you want a generic way to handle a

366
00:12:39,800 --> 00:12:41,233
同步消息
synchronous messages

367
00:12:41,400 --> 00:12:42,366
很好地做到这一点
well to do that

368
00:12:42,433 --> 00:12:45,433
让我们在接收循环中添加另一个通用子句
let's add another generic clause to the receive loop

369
00:12:46,366 --> 00:12:49,600
而且这里的消息模式永远不会有发件人
and the message pattern here will never have a sender

370
00:12:49,633 --> 00:12:50,566
只是一条消息
just a message

371
00:12:52,000 --> 00:12:53,766
异步消息子句
an asynchronous message clauses

372
00:12:53,766 --> 00:12:55,500
只需要递归调用
only need to recursively call

373
00:12:55,500 --> 00:12:57,066
监听状态循环
listen loop with the state

374
00:12:57,966 --> 00:13:00,466
我们将在另一个中处理消息特定代码
we'll take care of the message specific code in another

375
00:13:00,466 --> 00:13:01,800
多子句功能
multi clause function

376
00:13:01,866 --> 00:13:03,800
这将命名句柄演员
which will name handle cast

377
00:13:05,166 --> 00:13:07,100
因为它处理同步请求
because it handles a synchronous request

378
00:13:07,100 --> 00:13:08,066
客户端发送的
sent by the client

379
00:13:08,600 --> 00:13:11,100
它需要在当前状态下接收消息
it needs to take a message in the current state

380
00:13:11,500 --> 00:13:13,000
然后返回新状态
and then return the new state

381
00:13:15,333 --> 00:13:17,433
然后它将以那个新状态重现
then it's going to recurs with that new state

382
00:13:18,100 --> 00:13:19,566
所以不像处理调用
so unlike handle call

383
00:13:19,666 --> 00:13:20,133
处理
handle

384
00:13:20,133 --> 00:13:23,133
cast 不需要为客户端返回响应
cast doesn't need to return a response for the client

385
00:13:23,300 --> 00:13:24,866
因为客户不期望一个
because the client doesn't expect one

386
00:13:25,666 --> 00:13:27,733
所以现在让我们定义句柄转换
so now let's define handle cast

387
00:13:30,766 --> 00:13:32,966
我们只有一条演员信息要处理
we only have one cast message to handle

388
00:13:32,966 --> 00:13:34,933
所以我们只需要一个功能爪
so we only need one function claws

389
00:13:35,000 --> 00:13:36,233
信息很明确
the message is clear

390
00:13:37,366 --> 00:13:38,900
那么第二个参数是状态
then the second argument is state

391
00:13:39,100 --> 00:13:40,233
但我们不会使用状态
but we're not going to use the state

392
00:13:40,233 --> 00:13:41,366
所以我要使用下划线状态
so I'm going to use underscore state

393
00:13:41,366 --> 00:13:42,500
所以我们不会收到警告
so we don't get a warning

394
00:13:42,633 --> 00:13:45,033
然后我们需要做的就是返回新的状态
and then all we need to do is return the new state

395
00:13:45,066 --> 00:13:47,200
好吧，在这种情况下，这只是一个空列表
well that's just an empty list in this case

396
00:13:47,833 --> 00:13:49,866
所以现在我们可以移除这个爪子
so now we can remove this claws

397
00:13:49,866 --> 00:13:51,566
因为我们的通用爪子就在这里
because our generic claws right here

398
00:13:51,733 --> 00:13:52,533
处理那个
handles that

399
00:13:53,200 --> 00:13:54,866
所以现在如果我们把它保存起来并运行它
so now if we save that away and we run it

400
00:13:55,600 --> 00:13:57,000
哦，我们得到另一个错误
oh we get another error

401
00:13:57,100 --> 00:13:59,200
这是没有功能爪匹配错误
it's the no function claws matching error

402
00:13:59,200 --> 00:14:01,766
但这次是试图调用句柄演员
but this time is trying to call handle cast

403
00:14:01,766 --> 00:14:03,233
带停锤时间
with stop hammer time

404
00:14:03,633 --> 00:14:05,566
那是因为停止锤击时间
and that's because stop hammer time

405
00:14:05,700 --> 00:14:08,500
将在此处匹配此模式消息
will match this pattern right here message

406
00:14:08,600 --> 00:14:09,633
因为它只是一个变量
because it's just a variable

407
00:14:09,633 --> 00:14:10,633
它会吸收
it's going to soak up

408
00:14:10,666 --> 00:14:12,266
无论我们在这里收到什么信息
whatever message we get right here

409
00:14:12,866 --> 00:14:15,100
记住模式从上到下匹配
remember patterns are matched top to bottom

410
00:14:15,133 --> 00:14:17,800
并且所有意想不到的消息都会得到匹配
and all unexpected messages are going to get matched

411
00:14:17,800 --> 00:14:20,366
此模式消息为时过早
too early by this pattern message

412
00:14:21,000 --> 00:14:24,200
所以我们需要一种方法来匹配呼叫和投射消息
so we need a way to match call and cast messages

413
00:14:24,200 --> 00:14:25,000
但是然后让
but then let

414
00:14:25,366 --> 00:14:28,133
其他一切都属于意外条款
everything else fall through to the unexpected clause

415
00:14:28,600 --> 00:14:29,133
要做到这一点
to do that

416
00:14:29,133 --> 00:14:31,700
我们将消息标记为呼叫
we're going to tag the messages as either being a call

417
00:14:31,700 --> 00:14:33,933
或演员表，我们将通过添加
or a cast and we'll do that by adding an

418
00:14:33,933 --> 00:14:35,633
消息元组的元素
element to the message tuple

419
00:14:35,633 --> 00:14:38,133
所以我们将在那里进行原子调用
so we'll have the atom call right there

420
00:14:39,066 --> 00:14:42,000
我们将在这个元组中投射原子
and we'll have the atom cast inside of this tuple

421
00:14:43,033 --> 00:14:44,033
现在让它工作
now for this to work

422
00:14:44,033 --> 00:14:47,366
客户端必须发送带有这些标签的消息
the client must send messages with these tags

423
00:14:47,800 --> 00:14:48,600
没问题
well that's no problem

424
00:14:48,600 --> 00:14:49,433
因为我们已经有了
because we already have

425
00:14:49,433 --> 00:14:51,933
这些辅助函数调用 encase
these helper functions call encase

426
00:14:51,933 --> 00:14:53,000
使用的
that are used

427
00:14:53,000 --> 00:14:55,666
通过客户端接口函数发送消息
by the client interface functions to send messages

428
00:14:55,900 --> 00:14:56,833
所以打电话
so in call

429
00:14:57,200 --> 00:15:00,233
我们只是将原子调用添加到该消息中
we just add the atom call right there to that message

430
00:15:00,300 --> 00:15:02,800
并且 in cast 会改变它的信息
and in cast will change its message

431
00:15:02,900 --> 00:15:04,466
自动标记那些
to automatically tag those

432
00:15:05,533 --> 00:15:06,800
所以现在演员是
so now cast is

433
00:15:06,900 --> 00:15:08,266
实际上拉了一些重量
actually pulling some weight

434
00:15:08,333 --> 00:15:10,133
通过为我们标记消息
by tagging the messages for us

435
00:15:10,733 --> 00:15:12,500
是的，很好的是我们不必改变
yeah and what's nice is we don't have to change

436
00:15:12,600 --> 00:15:14,533
这些客户端接口函数中的任何一个
any of these client interface functions

437
00:15:14,800 --> 00:15:15,466
因为打电话
because the call

438
00:15:15,500 --> 00:15:17,833
和 cast 辅助函数做标记
and cast helper functions do the tagging

439
00:15:18,233 --> 00:15:21,433
如果我们把它保存起来，它应该可以工作，而且确实可以
if we save that away it should work and indeed it does

440
00:15:22,200 --> 00:15:23,300
所以让我们退后一步
so let's step back

441
00:15:23,333 --> 00:15:25,866
并将对所有人通用的东西分开
and separate what's generic to all

442
00:15:25,900 --> 00:15:28,666
服务器进程以及特定于此
server processes and what's specific to this

443
00:15:28,700 --> 00:15:30,633
特定的服务器进程
particular server process

444
00:15:30,966 --> 00:15:32,866
是的，让我们继续，从这里的顶部开始
yeah let's just go ahead and start at the top here

445
00:15:33,400 --> 00:15:36,066
所以这些客户端接口功能就在这里
so these client interface functions right here

446
00:15:36,133 --> 00:15:37,933
专门用于质押
are specific to pledging

447
00:15:38,166 --> 00:15:40,066
但是这些辅助功能在这里
but these helper functions down here

448
00:15:40,300 --> 00:15:41,433
虽然它们是通用的
while they're generic

449
00:15:41,566 --> 00:15:44,133
客户端接口函数使用它们来发送
they're used by the client interface functions to send

450
00:15:44,133 --> 00:15:45,733
呼叫或发送消息
call or cast messages

451
00:15:45,833 --> 00:15:48,266
所以让我们继续把它们移到一个新模块中
so let's go ahead and move these into a new module

452
00:15:49,433 --> 00:15:50,700
我只是要把它放在顶部
and I'm just going to put it at the top

453
00:15:50,700 --> 00:15:51,333
这里的文件
of the file here

454
00:15:51,333 --> 00:15:53,633
只是这样更容易在 sublime 中运行
just so it's easier to run inside of sublime

455
00:15:54,233 --> 00:15:56,166
我们将调用模块调查
and we're going to call the module survey

456
00:15:56,700 --> 00:15:57,766
通用服务器
generic server

457
00:15:58,333 --> 00:15:59,466
我就粘贴进去
and I'll just paste in

458
00:15:59,466 --> 00:16:00,700
那些辅助功能
those helper functions

459
00:16:01,900 --> 00:16:03,033
然后在质押服务器中关闭
then down in pledge server

460
00:16:03,033 --> 00:16:04,933
我们将为该模块起别名
we're going to alias that module in

461
00:16:07,500 --> 00:16:09,933
然后在我们的客户端界面功能下
and then down in our client interface functions

462
00:16:09,933 --> 00:16:11,966
我们在这里有电话
where we have the call right here

463
00:16:13,000 --> 00:16:15,800
好吧，这只是通用服务器
well that's just going to be generic server

464
00:16:15,833 --> 00:16:16,300
现在打电话
call now

465
00:16:16,300 --> 00:16:18,233
因为那是定义调用函数的地方
because that's where the call function is defined

466
00:16:18,633 --> 00:16:20,466
以同样的方式铸造
in the same way for cast

467
00:16:21,400 --> 00:16:23,800
我们被称为通用服务器演员
we're called generic server cast

468
00:16:24,166 --> 00:16:25,766
如果我们保存它并运行它
if we save that away and we run it

469
00:16:26,000 --> 00:16:28,600
毫不奇怪，它就像以前一样工作
well no surprise it works just as it did before

470
00:16:29,400 --> 00:16:31,600
接下来是这个监听循环就在这里
next up is this listen loop right here

471
00:16:32,500 --> 00:16:33,800
它也是通用的
and it's also generic

472
00:16:33,800 --> 00:16:34,500
什么也没有
there's nothing

473
00:16:34,500 --> 00:16:36,800
完全关于此代码的应用程序
application specific about this code at all

474
00:16:37,033 --> 00:16:39,200
应用程序特定代码
the application specific code

475
00:16:39,366 --> 00:16:41,266
生活在这些多子句功能中
lives in these multi clause functions

476
00:16:41,266 --> 00:16:43,066
处理调用和处理转换
handle call and handle cast

477
00:16:43,400 --> 00:16:46,866
你需要包含这个通用循环函数
you'd need to include this generic loop function in

478
00:16:46,900 --> 00:16:47,933
一种或另一种形式
one form or another

479
00:16:48,033 --> 00:16:50,266
编写任何服务器进程时
when writing any server process

480
00:16:50,366 --> 00:16:51,700
所以让我们继续移动它
so let's go ahead and move it

481
00:16:51,700 --> 00:16:53,533
也进入通用服务器模块
into the generic server module as well

482
00:16:57,900 --> 00:17:00,233
所以现在当监听循环收到一条消息时
so now when listen loop receives a message

483
00:17:00,233 --> 00:17:03,200
它需要调用相应的句柄调用
it needs to invoke the corresponding handle call

484
00:17:03,200 --> 00:17:04,833
或处理强制转换功能
or handle cast function

485
00:17:05,033 --> 00:17:07,666
这是在质押服务器模块中，所以这需要
that's in the pledge server module so this needs to be

486
00:17:07,966 --> 00:17:08,766
民意调查
survey

487
00:17:10,033 --> 00:17:11,800
以同样的方式处理呼叫
handle call in the same way

488
00:17:12,066 --> 00:17:14,766
我们需要在该模块上调用句柄转换
we need to call handle cast on that module

489
00:17:15,600 --> 00:17:17,733
现在回到我们的质押服务器模块
now going back down to our pledge server module

490
00:17:17,733 --> 00:17:18,866
我们还能搬什么
what else could we move

491
00:17:19,166 --> 00:17:20,933
有几个小改动
well with a couple minor changes

492
00:17:20,933 --> 00:17:23,100
我们可以移动这个启动函数
we could move this start function

493
00:17:23,200 --> 00:17:24,300
到我们的通用服务器
of to our generic server

494
00:17:24,300 --> 00:17:25,466
我只是要复制它
I'm just going to copy it

495
00:17:25,866 --> 00:17:27,100
我们会把它贴在这里
and we'll paste it up here

496
00:17:28,200 --> 00:17:29,300
我们将首先删除它
we'll remove this first

497
00:17:29,300 --> 00:17:31,266
io dot 放我们是因为我们没有开始承诺
io dot put us because we're not starting the pledge

498
00:17:31,266 --> 00:17:32,666
服务器这是更通用的
server this is more generic

499
00:17:32,900 --> 00:17:33,833
并且因为这
and since this

500
00:17:33,933 --> 00:17:35,233
下划线下划线模块
underscore underscore module

501
00:17:35,233 --> 00:17:37,333
下划线 下划线将扩大
underscore underscore will expand

502
00:17:37,433 --> 00:17:39,633
到将被服务的当前模块
to the current module which would be serviced

503
00:17:39,633 --> 00:17:41,133
在这种情况下是通用服务器
generic server in this case

504
00:17:41,366 --> 00:17:43,833
好吧，这条线将继续并产生
well this line is going to go ahead and spawn

505
00:17:44,100 --> 00:17:45,600
我们必须找到的监听循环
the listen loop that we have to find

506
00:17:45,600 --> 00:17:46,733
在这个模块里面
inside this module

507
00:17:47,333 --> 00:17:48,333
所以这一切都很好
so that's all good

508
00:17:48,566 --> 00:17:52,133
但是这个名字是特定于一个进程的
but this at name is specific to a process

509
00:17:52,166 --> 00:17:53,366
和这个初始状态
and this initial state

510
00:17:53,400 --> 00:17:54,966
在这种情况下是一个空列表
which in this case is an empty list

511
00:17:54,966 --> 00:17:56,666
特定于一个进程
is specific to a process

512
00:17:56,866 --> 00:17:58,666
所以要使这个启动功能通用
so to make this start function generic

513
00:17:58,666 --> 00:18:00,266
我们需要传入这两件事
we're going to need to pass in these two things

514
00:18:00,266 --> 00:18:02,966
作为参数，我们将传入初始状态
as argument so we'll pass in the initial state

515
00:18:03,466 --> 00:18:04,500
这是第一个论点
it's the first argument

516
00:18:04,533 --> 00:18:05,966
然后第二个将是名称
and then the second one will be the name

517
00:18:06,833 --> 00:18:08,833
然后我们将在这里替换一个空列表
and then we'll substitute here instead of an empty list

518
00:18:08,833 --> 00:18:10,000
这将是初始状态
it's going to be initial state

519
00:18:11,600 --> 00:18:12,033
接着
and then

520
00:18:12,033 --> 00:18:14,433
而不是使用 at name 我们只是要使用 name
instead of using at name we're just going to use name

521
00:18:15,366 --> 00:18:18,300
然后在我们的插件服务器的启动功能中下来
then down in the start function of our plug server

522
00:18:18,333 --> 00:18:20,666
在这里，我们不必再做这些事情了
right here we don't have to do this stuff anymore

523
00:18:20,766 --> 00:18:23,066
我们可以调用通用服务器启动
we can just call generic server start

524
00:18:23,433 --> 00:18:26,500
然后传入这个进程的初始状态
and then pass in this process's initial state

525
00:18:27,000 --> 00:18:28,900
这是一个空列表，然后是名称
which is an empty list and then the name

526
00:18:28,933 --> 00:18:30,266
我们的名字
which we have in at name

527
00:18:30,933 --> 00:18:32,033
保存并运行它
save that away and run it

528
00:18:32,366 --> 00:18:33,666
这同样有效
and that works just the same

529
00:18:34,566 --> 00:18:35,466
现在一切
and now everything

530
00:18:35,466 --> 00:18:38,166
质押服务器中的 else 特定于质押
else in pledge server is specific to pledging

531
00:18:38,566 --> 00:18:40,300
但如果我们回到我们的
but if we go back to our

532
00:18:40,333 --> 00:18:42,866
通用服务器并查看监听循环
generic server and look in the listen loop

533
00:18:43,033 --> 00:18:45,266
好吧，我们有硬涂层承诺服务器
well we've hard coated pledge server

534
00:18:45,433 --> 00:18:48,566
真正成为通用的通用服务器应该与
to truly be generic generic servers should work with

535
00:18:48,600 --> 00:18:49,266
任何模块
any module

536
00:18:49,266 --> 00:18:52,000
只要那个模块实现了这两个功能
as long as that module implements the two functions

537
00:18:52,000 --> 00:18:54,200
处理调用和处理转换
handle call and handle cast

538
00:18:54,533 --> 00:18:57,200
我们希望通用服务器回调
we want the generic server to call back

539
00:18:57,300 --> 00:18:59,433
到我们的质押服务器模块运行
to our pledge server module to run

540
00:18:59,433 --> 00:19:01,366
应用程序特定代码
the application specific code

541
00:19:01,666 --> 00:19:03,766
换句话说，质押服务器
in other words pledge server

542
00:19:03,900 --> 00:19:06,300
是我们的回调模块
is to be our callback module

543
00:19:07,066 --> 00:19:09,366
我们将有一个名为回调模块的变量
we'll have a variable called callback module that

544
00:19:09,366 --> 00:19:11,166
保留该回调模块
holds onto that callback module

545
00:19:11,300 --> 00:19:12,100
然后我们会打电话
and then we'll call

546
00:19:12,100 --> 00:19:14,766
处理该模块上的强制转换和处理调用
handle cast and handle call on that module

547
00:19:15,400 --> 00:19:17,766
那么我们将如何提供这个回调模块
so how are we going to feed this callback module

548
00:19:17,866 --> 00:19:19,066
进入通用服务器
into the generic server

549
00:19:19,300 --> 00:19:21,800
好吧，首先在我们的开始功能中
well first down in our start function here

550
00:19:22,566 --> 00:19:25,200
当我们启动通用服务器时，我们需要告诉它
when we start the generic server we need to tell it

551
00:19:25,200 --> 00:19:28,333
哪个模块实现了回调函数
which module implements the callback functions

552
00:19:28,400 --> 00:19:30,900
我们将回调模块作为第一个传递
and we'll pass the callback module as the first

553
00:19:30,900 --> 00:19:31,700
争论
argument

554
00:19:32,300 --> 00:19:32,966
现在回调
now the callback

555
00:19:32,966 --> 00:19:35,066
实现回调函数的模块
module that implements the callback functions

556
00:19:35,066 --> 00:19:36,033
这个模块是
is this module

557
00:19:36,033 --> 00:19:37,333
这是质押服务器模块
it's the pledge server module

558
00:19:37,333 --> 00:19:38,966
所以我们可以再次使用这个技巧
so we can use this trick again

559
00:19:40,366 --> 00:19:42,400
所以我们告诉通用服务器
so we're telling the generic server

560
00:19:42,433 --> 00:19:44,433
我们是当前模块
that we are the current module

561
00:19:44,433 --> 00:19:45,900
质押服务器模块
the pledge server module

562
00:19:46,200 --> 00:19:47,666
回调模块在哪里
where the callback module

563
00:19:48,200 --> 00:19:49,166
现在让它工作
now for that to work

564
00:19:49,166 --> 00:19:50,000
我们需要改变
we need to change

565
00:19:50,000 --> 00:19:51,233
这里的启动功能
the start function up here

566
00:19:51,233 --> 00:19:52,366
在通用服务器中
in generic server to

567
00:19:52,366 --> 00:19:54,900
将该回调模块作为第一个参数
take that callback module as the first argument

568
00:19:57,100 --> 00:19:59,200
然后最终我们需要将它传递给这个
and then ultimately we need to pass it down to this

569
00:19:59,200 --> 00:20:03,133
听循环，我们会记住 spawn 的第三个参数
listen loop we'll remember the third argument to spawn

570
00:20:03,533 --> 00:20:06,366
是要发送到的参数列表
is a list of arguments to send to

571
00:20:06,533 --> 00:20:07,900
生成的函数
the function that's getting spawned

572
00:20:07,900 --> 00:20:09,300
在这种情况下，它是监听循环
in this case it's listen loop

573
00:20:09,533 --> 00:20:10,300
所以现在
so right now

574
00:20:10,300 --> 00:20:12,533
监听循环只接受一个参数作为初始状态
listen loop just takes one argument the initial state

575
00:20:12,766 --> 00:20:14,566
但我们可以传递第二个参数
but we can pass it a second argument that's

576
00:20:14,566 --> 00:20:15,933
将成为我们的回调模块
going to be our callback module

577
00:20:16,433 --> 00:20:17,766
然后在监听循环中
then down in listen loop

578
00:20:18,200 --> 00:20:19,533
我们将在那里有回调模块
we'll have callback module there

579
00:20:21,100 --> 00:20:22,233
并且由于这个功能现在
and since this function now

580
00:20:22,233 --> 00:20:23,500
接受两个我们知道的论点
takes two arguments we know

581
00:20:23,500 --> 00:20:25,100
我们将不得不重复这些相同的
we're going to have to recurs with those same

582
00:20:25,100 --> 00:20:26,033
两个论点
two arguments

583
00:20:26,200 --> 00:20:28,333
所以我们将在那里传递回调模块
so we're going to have callback module passed there

584
00:20:29,200 --> 00:20:30,933
那里和那里
there and also there

585
00:20:31,700 --> 00:20:33,266
保存并运行它
save that away and run it

586
00:20:33,566 --> 00:20:35,266
嘿，很酷，这也有效
hey cool that works too

587
00:20:35,600 --> 00:20:36,400
谁
who

588
00:20:37,133 --> 00:20:39,566
所以现在通用服务器封装了所有
so now generic server encapsulates all

589
00:20:39,566 --> 00:20:42,700
服务器进程通用的通用代码
the generic code that's common to server processes

590
00:20:42,900 --> 00:20:44,600
它依赖于回调模块
it relies on a callback module

591
00:20:44,600 --> 00:20:46,233
比如pled服务器模块
such as the pled server module

592
00:20:46,333 --> 00:20:48,866
实现应用程序特定的代码
to implement the application specific code

593
00:20:48,966 --> 00:20:52,466
在回调函数中处理调用和句柄
in the callback functions handle call and handles

594
00:20:52,733 --> 00:20:54,433
所以在我们的质押服务器中
so down here in our pledge server

595
00:20:54,433 --> 00:20:55,833
我们可以更改此评论
we can change this comment

596
00:20:55,833 --> 00:20:56,800
服务器就在这里
server right here

597
00:20:57,000 --> 00:20:58,433
到服务器回调
to server callbacks

598
00:20:58,466 --> 00:21:00,966
因为这些只是被调用的回调
because these are just callbacks that are called by

599
00:21:00,966 --> 00:21:02,166
我们的通用服务器
our generic server

600
00:21:02,733 --> 00:21:03,833
现在我们处于一个伟大的
and now we're in a great

601
00:21:03,833 --> 00:21:06,866
开始使用 gen 服务器抽象的位置
position to start using the gen server abstraction

602
00:21:07,100 --> 00:21:08,266
接下来是
and it's up next

