1
00:00:00,333 --> 00:00:03,033
所以我一直在想，因为我们正在编写一个 Web 服务器
so I've been thinking since we're writing a web server

2
00:00:03,033 --> 00:00:04,233
毕竟不是吗
after all isn't it

3
00:00:04,233 --> 00:00:06,800
大约是时候我们开始从客户端发送我们的请求了
about time we start sending our request from a client

4
00:00:06,800 --> 00:00:08,300
你知道就像一个浏览器
you know like a browser

5
00:00:08,800 --> 00:00:09,866
这是很酷的事情
well here's the cool thing

6
00:00:09,866 --> 00:00:13,000
我们的处理程序模块知道如何转换请求
our handler module knows how to transform requests

7
00:00:13,000 --> 00:00:15,700
浏览器可以显示的响应
into responses that the browser can display

8
00:00:15,933 --> 00:00:17,366
所以我们需要做的就是
so all we need to do

9
00:00:17,366 --> 00:00:20,366
将该处理程序包装在一个薄的套接字层中
is wrap that handler in a thin socket layer

10
00:00:20,366 --> 00:00:23,466
允许任何 hdbb 客户端与我们的服务器交互
that lets any hdbb client interact with our server

11
00:00:23,633 --> 00:00:24,566
我们可以做到
and we can do that

12
00:00:24,566 --> 00:00:26,466
代码量相当有限
with a fairly limited amount of code

13
00:00:26,466 --> 00:00:28,433
通过使用早期的图书馆
by using an early library

14
00:00:29,266 --> 00:00:31,900
这是一个关于 Web 服务器如何工作的快速复习
here's a quick refresher on how a web server works

15
00:00:32,200 --> 00:00:32,966
服务器优先
the server first

16
00:00:32,966 --> 00:00:33,933
创建一个套接字
creates a socket

17
00:00:33,933 --> 00:00:36,533
侦听特定端口上的客户端连接
to listen for client connections on a specific port

18
00:00:36,533 --> 00:00:38,833
数字例如端口 4000
number for example port 4000

19
00:00:39,166 --> 00:00:41,933
您可以将套接字视为通信通道
you can think of a socket as a communication channel

20
00:00:41,933 --> 00:00:44,900
在任何两个程序之间有一个客户端和一个服务器
between any two programs a client and a server

21
00:00:45,033 --> 00:00:47,933
在我们的例子中，我们假设客户端是一个浏览器
in our case we'll assume the client is a browser

22
00:00:48,033 --> 00:00:50,466
虽然它可以是任何 http 客户端
though it could be any http client

23
00:00:51,033 --> 00:00:52,533
创建监听套接字后
after creating the listening socket

24
00:00:52,533 --> 00:00:55,233
服务器等待接受客户端连接
the server waits to accept a client connection

25
00:00:55,233 --> 00:00:56,900
在那个监听套接字上
on that listening socket

26
00:00:57,533 --> 00:00:59,300
发送一个 http 请求
to send an http request

27
00:00:59,300 --> 00:01:02,466
浏览器向服务器发送连接请求
the browser sends a connection request to the server

28
00:01:02,566 --> 00:01:03,533
在端口号上
on the port number

29
00:01:03,700 --> 00:01:06,066
和服务器正在监听的 IP 地址
and ip address where the server is listening

30
00:01:06,466 --> 00:01:09,233
服务器接受连接并创建一个新的
the server accepts the connection and creates a new

31
00:01:09,233 --> 00:01:10,400
客户端套接字
client socket

32
00:01:10,400 --> 00:01:11,466
一个新的插座是
a new socket is

33
00:01:11,466 --> 00:01:14,300
需要，以便服务器可以继续侦听
needed so that the server can continue listening for

34
00:01:14,333 --> 00:01:17,033
监听套接字上的其他连接请求
other connection requests on the listening socket

35
00:01:17,333 --> 00:01:20,900
然后浏览器将http请求发送到服务器
the browser then sends the http request to the server

36
00:01:21,033 --> 00:01:22,466
通过客户端套接字
over the client socket

37
00:01:22,766 --> 00:01:25,533
服务器接收请求生成
the server receives the request generates

38
00:01:25,533 --> 00:01:28,133
出适当的http响应
out an appropriate http response

39
00:01:28,333 --> 00:01:30,933
并将响应发送回浏览器
and sends that response back to the browser

40
00:01:30,933 --> 00:01:32,700
在同一个客户端套接字上
over the same client socket

41
00:01:33,300 --> 00:01:35,933
最后服务器关闭客户端套接字以
finally the server closes the client socket to

42
00:01:35,933 --> 00:01:37,066
结束连接
end the connection

43
00:01:37,566 --> 00:01:38,433
服务器现在是
the server is now

44
00:01:38,466 --> 00:01:40,700
准备好接受下一个连接请求
ready to accept the next connection request

45
00:01:40,700 --> 00:01:42,033
在监听套接字上
on the listening socket

46
00:01:42,866 --> 00:01:43,533
这样
in this way

47
00:01:43,533 --> 00:01:45,933
忽略花里胡哨的东西，比如保持活力
ignoring bells and whistles such as keep alive

48
00:01:45,933 --> 00:01:47,866
就像简单的网络服务器处理一个
as simple web server handles one

49
00:01:47,866 --> 00:01:50,900
一次http请求响应周期
http request response cycle at a time

50
00:01:51,766 --> 00:01:53,366
所以基本上一个网络服务器有
so basically a web server has

51
00:01:53,366 --> 00:01:56,366
两个具有不同职责的独立层
two separate layers with distinct responsibilities

52
00:01:56,800 --> 00:01:58,900
有一个套接字层负责
there's a socket layer that's responsible for

53
00:01:58,900 --> 00:02:01,100
与 hdp 客户端通信
communicating with hdp clients

54
00:02:01,166 --> 00:02:03,233
它不知道如何处理请求
and it doesn't know how to handle requests

55
00:02:03,433 --> 00:02:05,966
所以它将这个责任委托给一个请求
so it delegates that responsibility to a request

56
00:02:05,966 --> 00:02:07,933
第二层的处理程序
handler which is the second layer

57
00:02:08,400 --> 00:02:09,933
负责的处理程序
the handlers responsible for

58
00:02:09,933 --> 00:02:11,566
转换请求字符串
transforming a request string

59
00:02:11,800 --> 00:02:12,966
进入响应字符串
into a response string

60
00:02:13,266 --> 00:02:15,566
它不关心请求来自哪里
and it doesn't care where the request came from

61
00:02:15,666 --> 00:02:17,200
或响应的去向
or where the response is going

62
00:02:17,833 --> 00:02:19,666
现在我们已经有了一个处理模块
now we already have a handler module that

63
00:02:19,666 --> 00:02:21,066
解析和路由请求
parses and router requests

64
00:02:21,066 --> 00:02:23,000
并返回适当的响应
and returns an appropriate response

65
00:02:23,333 --> 00:02:25,100
我们只需要设置一些套接字
we just need to set up some sockets

66
00:02:25,100 --> 00:02:27,733
以便http客户端可以与我们的应用程序交互
so that http clients can interface with our app

67
00:02:27,866 --> 00:02:28,666
通过网络
over the network

68
00:02:29,266 --> 00:02:31,933
为此，我们将使用一个负责处理的套接字库
to do this we'll use a socket library that takes care

69
00:02:31,933 --> 00:02:33,833
所有底层细节
of all the low level details

70
00:02:33,866 --> 00:02:35,966
但它不会是一个长生不老药库
but it won't be an elixir library

71
00:02:35,966 --> 00:02:38,633
因为长生不老药不需要重新发明那个轮子
because elixir doesn't need to reinvent that wheel

72
00:02:38,933 --> 00:02:42,400
early 已经拥有一个经过验证的优秀套接字库
early already has an excellent proven socket library

73
00:02:42,466 --> 00:02:43,966
命名为 jen tcp
named jen tcp

74
00:02:44,066 --> 00:02:46,866
并且该库已预先安装了 elixir
and that library is pre installed with elixir

75
00:02:47,533 --> 00:02:49,866
因为 gen 是一个城市图书馆
since gen is an urban library

76
00:02:49,866 --> 00:02:52,366
它的文件在城市
the documentation for it is at urban

77
00:02:52,400 --> 00:02:55,300
org dock，您会立即注意到
org dock and you'll notice right away at the

78
00:02:55,300 --> 00:02:56,800
上面写着城市
top it says urban

79
00:02:57,466 --> 00:03:01,933
top now top 代表开放的电视广播平台
top now top stands for open telecast platform

80
00:03:01,933 --> 00:03:02,933
这是误导
which is misleading

81
00:03:02,933 --> 00:03:05,566
因为它不是特定于电信的
because it's not specific to telecommunications

82
00:03:05,666 --> 00:03:07,000
但伯爵原本是
but earling was originally

83
00:03:07,000 --> 00:03:09,400
专为构建电信系统而设计
designed for building telecommunication systems

84
00:03:09,400 --> 00:03:12,066
并且经常发生名称卡住
and as often happens the name stuck

85
00:03:12,333 --> 00:03:14,433
那么为什么 top 在今天仍然相关
so why is top still relevant today

86
00:03:14,833 --> 00:03:15,766
事实证明
while it turns out

87
00:03:15,766 --> 00:03:18,466
今天的高可用性系统也有类似的需求
today's high availability systems have similar needs

88
00:03:18,466 --> 00:03:21,133
包括并发的电视广播系统
the telecast systems including concurrency

89
00:03:21,300 --> 00:03:24,166
容错能力和分布
fault tolerant capability and distribution

90
00:03:24,366 --> 00:03:25,566
因为 top 是
and since top was

91
00:03:25,566 --> 00:03:27,533
设计为通用框架
designed as a general purpose framework

92
00:03:27,633 --> 00:03:29,500
一组库和模式
a set of libraries and patterns

93
00:03:29,566 --> 00:03:32,033
它使我们能够构建这些类型的系统
it enables us to build these kinds of systems with

94
00:03:32,033 --> 00:03:33,033
更轻松
greater ease

95
00:03:33,300 --> 00:03:36,200
现在记住这一切始于大约 20 年前
now remember this all started some 20 years ago now

96
00:03:36,333 --> 00:03:37,266
同时
and in the meantime

97
00:03:37,266 --> 00:03:40,400
top 已经发展成为一个久经考验的基础
top has evolved into a battle proven foundation

98
00:03:40,466 --> 00:03:42,733
在其上构建现代应用程序
on which to build modern applications

99
00:03:43,166 --> 00:03:45,766
所以要找到 gntc 我们只需要走到左手边
so to find gntc we just go over to the left hand

100
00:03:45,766 --> 00:03:47,800
导航到这里并点击模块
nav here and click on modules

101
00:03:48,100 --> 00:03:50,766
我们现在看到一堆统治图书馆
and we see a bunch of ruling libraries now

102
00:03:50,766 --> 00:03:53,200
这些库是用裁定写的，但我们可以调用
these libraries are written in ruling but we can call

103
00:03:53,233 --> 00:03:55,033
来自 elixir 的任何统治图书馆
any ruling library from elixir

104
00:03:55,033 --> 00:03:57,700
因为elixir代码被编译成bite代码
because elixir code is compiled into bite code

105
00:03:57,733 --> 00:03:59,300
在催促的虚拟机上运行
that runs on the urging vm

106
00:03:59,566 --> 00:04:00,033
这是
and this is

107
00:04:00,066 --> 00:04:03,233
巨大，因为这意味着长生不老药兼容所有
huge because it means elixir is compatible with all

108
00:04:03,300 --> 00:04:04,833
现有或 lang 库
existing or lang libraries

109
00:04:05,166 --> 00:04:06,900
我们在寻找温柔的图书馆
we're looking for the gentle library

110
00:04:06,900 --> 00:04:07,933
所以我们只需向下滚动
so we just scroll down

111
00:04:08,566 --> 00:04:10,500
这里有很多图书馆
there's a ton of libraries inside of here

112
00:04:11,166 --> 00:04:12,833
下到 gen 部分
go down to the gen section

113
00:04:14,566 --> 00:04:16,500
顺便说一下，当你看到 gen 下划线
and by the way when you see gen underscore

114
00:04:16,533 --> 00:04:18,366
它只代表通用
it just stands for generic

115
00:04:18,400 --> 00:04:20,866
所以我们正在寻找 gen tcp 我会点击它
so we're looking for gen tcp I'll click on it

116
00:04:21,466 --> 00:04:22,766
我们在它说的描述中看到
and we see in the description it says

117
00:04:22,766 --> 00:04:25,100
该模块提供与通信的功能
this module provides functions for communicating with

118
00:04:25,100 --> 00:04:27,333
使用 to 协议的套接字
sockets using the to protocol

119
00:04:27,400 --> 00:04:29,000
这正是我们需要的
which is exactly what we need

120
00:04:29,633 --> 00:04:31,400
现在这个第一个例子在这里
now this first example down here

121
00:04:31,466 --> 00:04:34,133
显示如何在 http 客户端中编写
shows how to write in http client

122
00:04:34,333 --> 00:04:36,600
但我们将使用浏览器作为客户端
but we're going to be using a browser as the client

123
00:04:36,866 --> 00:04:39,066
我们需要写出这个等式的服务器端
we need to write the server side of this equation

124
00:04:39,066 --> 00:04:40,033
所以我要下去
so I'm going to go down

125
00:04:40,033 --> 00:04:42,466
再进一步，有一个服务器示例
a little bit further and there's a server example

126
00:04:42,566 --> 00:04:44,000
我只是要复制这个
and I'm just going to copy this

127
00:04:44,300 --> 00:04:45,933
我们会以此为起点
and we'll use it as a starting point

128
00:04:46,533 --> 00:04:49,033
然后返回并在 lib 调查目录中升华
then back over and sublime in the lib survey directory

129
00:04:49,033 --> 00:04:52,400
我将创建一个名为 http server 的新文件
I'm going to create a new file called http server

130
00:04:52,533 --> 00:04:55,033
ex，然后粘贴该代码
ex and then just paste in that code

131
00:04:55,600 --> 00:04:57,600
现在乍一看，这看起来很熟悉
now at first glance this looks familiar

132
00:04:57,600 --> 00:05:00,533
我们看到的功能与我们在图中看到的相匹配
we see functions matching what we saw in the diagram

133
00:05:00,533 --> 00:05:01,966
所以有一个监听功能
so there's a listen function

134
00:05:02,066 --> 00:05:03,266
一个异常函数
an except function

135
00:05:03,400 --> 00:05:05,533
有这个自定义做接收功能
there's this custom do receive function

136
00:05:05,566 --> 00:05:06,766
接收数据
to receive the data

137
00:05:06,900 --> 00:05:08,233
这就是这个例子所使用的
that's just what this example used

138
00:05:08,233 --> 00:05:10,633
我们将把它改成一分钟后接收
we're going to change that to just receive in a minute

139
00:05:10,700 --> 00:05:12,566
然后我们有关闭功能
and then we have the close function

140
00:05:12,966 --> 00:05:14,333
现在这些是统治功能
now these are ruling functions

141
00:05:14,333 --> 00:05:15,800
我们可以从长生不老药中调用它们
and we can call them from elixir

142
00:05:15,800 --> 00:05:18,200
但我们需要转换或转码
but we need to convert or transcode

143
00:05:18,233 --> 00:05:19,800
这段代码长生不老药
this code to elixir

144
00:05:20,333 --> 00:05:22,733
事实证明这是一个相当简单的
this turns out to be a fairly straightforward

145
00:05:22,733 --> 00:05:24,266
和指导性练习
and instructive exercise

146
00:05:24,400 --> 00:05:26,300
因为作为一个长生不老药开发者
since as an elixir developer

147
00:05:26,433 --> 00:05:27,833
你有时会想要使用
you'll sometimes want to use

148
00:05:27,833 --> 00:05:29,766
现有的早期图书馆
an existing early library

149
00:05:29,766 --> 00:05:31,700
而不是重新发明轮子
instead of reinventing the wheel

150
00:05:32,000 --> 00:05:35,066
所以知道如何调用早期库是值得的
so it pays to know how to call early libraries

151
00:05:35,066 --> 00:05:37,233
从长生不老药我会粘贴它
from elixir I'll paste it

152
00:05:37,233 --> 00:05:39,033
再次注释掉earland代码
again and comment out the earland code

153
00:05:39,033 --> 00:05:40,533
所以我们可以看到差异
so we can see the differences

154
00:05:41,333 --> 00:05:43,100
所以这里的第一行服务器
so this first line here server

155
00:05:43,133 --> 00:05:44,833
这是一个耳区功能
this is an earland function

156
00:05:44,966 --> 00:05:46,666
所以让我们把它改成一个长生不老药函数
so let's just change it to an elixir function

157
00:05:46,666 --> 00:05:49,466
它不需要任何参数，所以它只是 def server 做的
it doesn't take any argument so it's just def server do

158
00:05:51,366 --> 00:05:53,733
现在结束，我要把这些烧焦
and end now I'm going to scorch these over

159
00:05:55,233 --> 00:05:57,733
我们走了，所以第一行在这里
there we go so this first line here

160
00:05:57,766 --> 00:06:00,666
创建一个侦听套接字，它调用侦听来执行此操作
creates a listening socket it calls listen to do that

161
00:06:00,833 --> 00:06:03,066
它将在端口 5 6 7 8
and it's going to be on port 5 6 7 8

162
00:06:03,266 --> 00:06:04,666
然后它有一些选择
and then it has some options

163
00:06:04,666 --> 00:06:06,466
这是方括号中的列表
here's a list in square brackets

164
00:06:06,666 --> 00:06:09,266
现在因为这段代码来自 erling 文档
now since this code comes from erling documentation

165
00:06:09,333 --> 00:06:11,300
它遵循早期命名约定
it follows earling naming conventions

166
00:06:11,300 --> 00:06:12,266
稍微
which are slightly

167
00:06:12,266 --> 00:06:13,266
不同于灵药
different from elixir

168
00:06:13,466 --> 00:06:16,166
因此，让我们逐步将其转码为长生不老药
so let's walk through transcoding it to elixir

169
00:06:16,666 --> 00:06:19,066
第一个我们在左侧有这个元组
1st we have this tuple on the left hand side

170
00:06:19,400 --> 00:06:20,800
我们模式匹配它
and we pattern match it

171
00:06:20,800 --> 00:06:22,800
与我们期望得到的回报相反
against what we expect to be returned

172
00:06:22,800 --> 00:06:24,166
从这个监听函数
from this listen function

173
00:06:24,566 --> 00:06:26,700
现在我们不用担心任何空气状况
now we're not going to worry about any air conditions

174
00:06:26,733 --> 00:06:28,866
所以我们希望这会成功
so we expect this to be successful

175
00:06:29,000 --> 00:06:31,200
所以我们会回来的，你注意到了
so we're going to get back ok and you notice ok

176
00:06:31,200 --> 00:06:32,933
这里都是小写
here is all lowercase

177
00:06:33,200 --> 00:06:35,300
以小写字母开头的井名
well name starting with lowercase letters

178
00:06:35,300 --> 00:06:37,033
早期是原子
in early are atoms

179
00:06:37,033 --> 00:06:39,300
在长生不老药中，我们需要在这里添加一个冒号
in elixir we need to add a colon here

180
00:06:39,500 --> 00:06:41,066
这是一个长生不老药原子
this is an elixir atom

181
00:06:41,533 --> 00:06:44,566
那么元组中的第二个元素就是这个 l sock
then the second element in the tuple is this l sock

182
00:06:44,566 --> 00:06:46,700
这是变量，它将被绑定
and this is the variable and it's going to be bound

183
00:06:46,700 --> 00:06:48,200
到新的监听套接字
to the new listening socket

184
00:06:48,200 --> 00:06:50,466
监听函数返回的东西
the thing returned by the listen function

185
00:06:50,700 --> 00:06:53,933
在早期的变量中以大写字母开头
in variables in earling start with uppercase letters

186
00:06:53,966 --> 00:06:54,933
但在长生不老药中
but in elixir

187
00:06:55,033 --> 00:06:56,066
它们是小写字母
they're lowercase letters

188
00:06:56,066 --> 00:06:58,666
所以我们只是要把它转换成 l sock
so we're just going to convert this to l sock

189
00:06:59,300 --> 00:06:59,966
这就是它
so that's it for the

190
00:06:59,966 --> 00:07:01,500
元组，如果我们来到这里
tuple and if we come over here

191
00:07:01,566 --> 00:07:05,466
我们有 erling 模块 g 然后函数是
we've got the erling module g and then the function is

192
00:07:05,766 --> 00:07:09,100
好好听从 elixir 中引用早期的模块
listen well to reference earlier modules from elixir

193
00:07:09,100 --> 00:07:10,933
我们需要在这里的开头使用冒号
we need to use a colon at the beginning here

194
00:07:10,933 --> 00:07:12,900
所以它将是冒号 g
so it's going to be colon g

195
00:07:13,100 --> 00:07:14,133
然后调用函数
and then to call the function

196
00:07:14,133 --> 00:07:16,066
我们用一个点替换这个冒号
we replace this colon with a dot

197
00:07:16,700 --> 00:07:18,566
就像在 elixir 中调用任何函数一样
so just like calling any function in elixir

198
00:07:18,566 --> 00:07:20,233
我们使用一个点，然后是函数名
we use a dot and then the function name

199
00:07:20,266 --> 00:07:21,500
模块在它之前
the module comes before it

200
00:07:21,500 --> 00:07:22,866
但这里唯一的区别是
but the only difference here is

201
00:07:23,100 --> 00:07:25,400
erelong 模块需要以冒号开头
erelong modules need to start with a colon

202
00:07:25,400 --> 00:07:26,733
他们都是小写的
and they're all lowercase

203
00:07:27,200 --> 00:07:29,033
那么listen函数有两个参数
then the listen function takes two arguments

204
00:07:29,033 --> 00:07:29,800
端口号
the port number

205
00:07:29,800 --> 00:07:32,900
然后是方括号中的选项列表
and then the list of options here in square brackets

206
00:07:33,100 --> 00:07:34,300
好吧，这又是一个
well again this is a

207
00:07:34,300 --> 00:07:36,966
小写二进制，我们知道这是一个原子
lowercase binary and we know that's an atom

208
00:07:36,966 --> 00:07:39,300
在长生不老药的早期，我们必须使用冒号
in early in elixir we have to use a colon

209
00:07:39,700 --> 00:07:41,100
与数据包相同的方式
the same way with packet

210
00:07:42,033 --> 00:07:43,166
并活跃在这里
and active here

211
00:07:43,766 --> 00:07:46,066
所以现在我们有一个列表，其中第一个
so now what we have is a list where the first

212
00:07:46,066 --> 00:07:47,900
元素是亚当二进制
element is an adam binary

213
00:07:47,900 --> 00:07:49,966
第二个元素实际上是一个元组
the second element is actually a tuple

214
00:07:50,400 --> 00:07:52,700
其中第一个元素是一个原子，然后是一个值
where the first element is an atom and then a value

215
00:07:52,700 --> 00:07:55,500
零，然后列表中的第三个元素是
zero and then the third element in the list is

216
00:07:55,533 --> 00:07:56,933
也是一个活跃的元组
also a tuple active

217
00:07:56,966 --> 00:07:58,100
和价值假
and the value false

218
00:07:58,500 --> 00:07:59,366
这会奏效
and that will work

219
00:07:59,500 --> 00:08:02,033
但是在长生不老药中有一种更自动的方法来做到这一点
but there's a more automatic way to do this in elixir

220
00:08:02,533 --> 00:08:04,700
因为我们有一个元组列表
because we have a list of tuples

221
00:08:05,133 --> 00:08:07,566
其中元组的第一项是原子
where the first item of the tuple is an atom

222
00:08:07,733 --> 00:08:09,700
我们可以使用长生不老药关键字列表
we can use an elixir keyword list

223
00:08:10,066 --> 00:08:12,533
如果我们只是去掉花括号，这样做的方法
the way to do that if we just drop the curly braces

224
00:08:12,533 --> 00:08:15,066
在这里，我们把冒号放在这个的另一边
here and we put the colon on the other side of this

225
00:08:16,066 --> 00:08:17,400
所以它是零数据包
so it's packet zero

226
00:08:17,800 --> 00:08:19,766
放下那个花括号然后放在这里
drop that curly brace then down here

227
00:08:20,800 --> 00:08:21,600
脱掉这个
take this off

228
00:08:22,900 --> 00:08:23,866
煤和假
coal and false

229
00:08:24,233 --> 00:08:25,033
并放弃
and drop that

230
00:08:25,466 --> 00:08:27,366
这只是更重要的方法
and that's just the more significant way to do it

231
00:08:27,500 --> 00:08:29,700
但在内部它表示为相同
but internally it's represented as the same

232
00:08:29,766 --> 00:08:31,300
我们开始使用的两个极点列表
list of two poles we started with

233
00:08:31,833 --> 00:08:33,300
不要担心这些选项意味着什么
and don't worry about what these options mean

234
00:08:33,300 --> 00:08:35,166
现在我们将在一分钟内回到那个
right now we'll come back to that in a minute

235
00:08:35,533 --> 00:08:38,733
然后最后这一行的最后一件事是逗号
and then finally the last thing on this line is a comma

236
00:08:38,900 --> 00:08:40,900
在earl中，函数的主体是
and in earl the body of a function is

237
00:08:40,900 --> 00:08:43,866
一个或多个用逗号分隔的早期表达式
one or more early expressions separated by a comma

238
00:08:43,866 --> 00:08:45,666
但我们不需要 elixir 中的逗号
but we don't need the commas in elixir

239
00:08:46,500 --> 00:08:48,633
第二行电话接受
the 2nd line calls accept

240
00:08:48,733 --> 00:08:50,933
暂停它是一个阻塞调用
which suspends it's a blocking call

241
00:08:51,100 --> 00:08:53,400
它等待接受客户端连接
and it waits to accept a client connection

242
00:08:53,400 --> 00:08:55,833
在侦听套接字上，这是这种损失
on the listening socket which is this loss

243
00:08:56,233 --> 00:08:58,066
以及建立连接时
and when a connection is established

244
00:08:58,166 --> 00:09:01,533
此 sock 绑定到新的客户端套接字
this sock is bound to the new client socket

245
00:09:01,766 --> 00:09:02,966
所以让我们继续转换这个
so let's go ahead and convert this

246
00:09:02,966 --> 00:09:04,500
这将是原子好吧
this is going to be the atom okay

247
00:09:04,866 --> 00:09:06,733
这将是一个可变袜子
this is going to be a variable sock

248
00:09:06,800 --> 00:09:08,433
所以小写长生不老药
so lowercase an elixir

249
00:09:09,300 --> 00:09:10,633
结肠起床
colon getup

250
00:09:11,600 --> 00:09:13,733
点除了，这只是
dot except and this is just

251
00:09:13,733 --> 00:09:15,766
l sock，我们可以删除最后的评论
l sock and we can remove the comment at the end

252
00:09:16,500 --> 00:09:19,266
现在在第 3 行我们需要接收请求
now on the 3rd line we need to receive the request

253
00:09:19,333 --> 00:09:22,133
通过从客户端套接字读取来自客户端
from the client by reading from the client socket

254
00:09:22,166 --> 00:09:23,766
在这种情况下是袜子
which is sock in this case

255
00:09:24,000 --> 00:09:24,566
你注意到
and you notice

256
00:09:24,566 --> 00:09:27,133
此示例使用自定义的 do 接收功能
this example uses the custom do receive function

257
00:09:27,566 --> 00:09:28,766
所以让我们继续转换它
so let's go ahead and convert it

258
00:09:28,766 --> 00:09:30,066
这将是亚当
this is going to be adam

259
00:09:30,066 --> 00:09:33,233
好的，这个 bin 变量将被绑定
okay this bin variable is going to be bound

260
00:09:33,333 --> 00:09:34,533
到请求字符串
to the request string

261
00:09:34,533 --> 00:09:37,300
它的名字是 bin 因为它是一个二进制字符串
it's name bin because it's a binary string

262
00:09:37,600 --> 00:09:38,366
这是一个变量
it's a variable

263
00:09:38,366 --> 00:09:40,333
所以我们要把它改成小写的bin
so we're going to change it to a lowercase bin

264
00:09:40,766 --> 00:09:42,233
然后而不是打电话做接收
then instead of calling do receive

265
00:09:42,233 --> 00:09:44,700
在这里我们将调用 go tcp
right here we're going to call go tcp

266
00:09:45,400 --> 00:09:48,433
有一个函数叫做receive re
there's a function called receive r e

267
00:09:49,300 --> 00:09:51,466
我们在那个客户端套接字中传递它
we pass it in that client socket

268
00:09:52,033 --> 00:09:53,733
然后在这里不使用列表
and then instead of using a list here

269
00:09:53,833 --> 00:09:55,133
我们将传入零
we're going to pass in zero

270
00:09:55,366 --> 00:09:56,933
这意味着我们希望收到
that means we want to receive

271
00:09:57,033 --> 00:09:58,266
所有可用的叮咬
all the available bites

272
00:09:58,266 --> 00:10:00,533
所以所有可用的食物都将被退回
so all available bites will be returned

273
00:10:00,666 --> 00:10:02,666
它将被绑定到变量 bin
and it will be bound to the variable bin

274
00:10:03,066 --> 00:10:04,800
然后我们可以在最后去掉那个评论
and then we can get rid of that comment at the end

275
00:10:05,333 --> 00:10:06,700
现在我们有了请求字符串
now that we have the request string

276
00:10:06,700 --> 00:10:09,300
在这里，我们可以继续关闭该客户端套接字
here we can go ahead and close that client socket

277
00:10:09,700 --> 00:10:11,466
所以这将是亚当，好吧
so this is going to be the adam okay

278
00:10:12,733 --> 00:10:14,933
起床点衣服
getup dot clothes

279
00:10:15,400 --> 00:10:18,366
去掉那个逗号，这只是小写套接字
get rid of that comma and this is just lowercase socket

280
00:10:18,933 --> 00:10:21,900
然后这里的最后一行只是返回 bin
and then the final line here just returns bin

281
00:10:21,933 --> 00:10:23,233
这是请求字符串
that's the request string

282
00:10:23,733 --> 00:10:25,133
所以我们将更改为小写 b
so we're changes to a lowercase b

283
00:10:25,133 --> 00:10:26,266
我们可以删除它
and we can remove this

284
00:10:26,400 --> 00:10:27,366
点在最后
dot at the end

285
00:10:27,700 --> 00:10:29,933
获得点意味着我们在函数的末尾
in earning the dot means we're at the end of a function

286
00:10:29,933 --> 00:10:31,366
但我们在长生不老药中不需要它
but we don't need that in elixir

287
00:10:31,966 --> 00:10:32,733
最后我们知道了
finally we know that

288
00:10:32,733 --> 00:10:35,000
所有的 elixir 函数都需要存在于一个模块中
all elixir functions need to live in a module

289
00:10:35,033 --> 00:10:36,500
所以让我们把它放在一个模块中
so let's put this in a module

290
00:10:37,866 --> 00:10:40,266
我们称之为调查 htp 服务器
we'll call it survey htp server

291
00:10:42,500 --> 00:10:43,433
这是我们的功能
there's our function

292
00:10:44,100 --> 00:10:44,900
我们去吧
and there we go

293
00:10:45,400 --> 00:10:48,500
现在让我们使用我们的 http 服务器来进行性爱
now let's take our http server for our spin in sex

294
00:10:49,533 --> 00:10:50,166
所以我们将从
so we'll start with

295
00:10:50,166 --> 00:10:51,866
调查点顶服务器
survey dot top server

296
00:10:52,366 --> 00:10:54,166
点服务器，这是函数的名称
dot server that's the name of the function

297
00:10:54,933 --> 00:10:55,366
好吧
alright

298
00:10:55,366 --> 00:10:58,066
索引挂起，因为它正在等待连接
index hangs because it's waiting for a connection

299
00:10:58,066 --> 00:10:59,400
所以让我们转到浏览器
so let's head over to a browser

300
00:10:59,766 --> 00:11:01,600
我们要去本地主机
and we're going to go to local host

301
00:11:01,633 --> 00:11:03,633
它将是 5 6 7 8
and it's going to be 5 6 7 8

302
00:11:03,633 --> 00:11:04,433
那是港口
that's the port

303
00:11:05,433 --> 00:11:07,066
他注意到说这个页面不起作用
he notices says this page isn't working

304
00:11:07,066 --> 00:11:08,833
本地主机没有发送任何数据
local hosts didn't send any data

305
00:11:08,833 --> 00:11:09,300
那就是
well that's

306
00:11:09,300 --> 00:11:10,633
因为我们的例子实际上并没有
because our example doesn't actually

307
00:11:10,633 --> 00:11:12,433
将响应发送回浏览器
send a response back to the browser

308
00:11:12,700 --> 00:11:14,300
但如果我们回来看看六
but if we come back and look at six

309
00:11:14,600 --> 00:11:16,633
好吧，我们看到它打印了请求
well we see that it prints the request

310
00:11:17,200 --> 00:11:19,533
该服务器函数返回的
that was returned by that server function

311
00:11:20,033 --> 00:11:20,266
记住
remember

312
00:11:20,266 --> 00:11:22,966
服务器函数最后只返回 bin
the server function just returns bin at the end

313
00:11:22,966 --> 00:11:24,900
这就是它收到的请求
and that's the request that it got from

314
00:11:25,000 --> 00:11:28,100
接收所以修复只是打印出来
the receive so fix is just printing out

315
00:11:28,366 --> 00:11:29,966
该请求是一个字符串
that request which is a string

316
00:11:30,600 --> 00:11:31,800
这就是我们在这里看到的
and that's what we're seeing right here

317
00:11:32,266 --> 00:11:33,266
然后就完成了
and then it's done

318
00:11:33,266 --> 00:11:36,066
因为服务端函数只处理一个请求
because the server function only handles one request

319
00:11:36,800 --> 00:11:40,066
这实际上给了我们一个很好的开始来完成它
this actually gives us a great start to finish it off

320
00:11:40,066 --> 00:11:41,066
我们只需要
we simply need to

321
00:11:41,066 --> 00:11:45,166
将有效的 http 响应发送回客户端
send a valid http response back to the client

322
00:11:45,466 --> 00:11:46,633
然后循环
and then loop

323
00:11:46,666 --> 00:11:47,966
回到接受线
back to the accept line

324
00:11:47,966 --> 00:11:50,366
等待下一个连接请求
to wait for the next connection request

325
00:11:50,966 --> 00:11:52,166
所以让我们看看还有什么
so let's look at what a more

326
00:11:52,166 --> 00:11:54,100
完全充实的服务器看起来像
fully fleshed out server would look like

327
00:11:54,600 --> 00:11:55,800
我要贴一些准备好的
I'm going to paste some prepared

328
00:11:55,800 --> 00:11:58,233
替换此文件中当前内容的代码
code to replace what's currently in this file

329
00:11:58,866 --> 00:12:00,033
然后我们要关闭侧边栏
and then we're going to close the sidebar

330
00:12:00,033 --> 00:12:01,066
只是为了我们有更多的空间
just so we have more room

331
00:12:01,533 --> 00:12:03,733
不用担心您会在代码包中找到此代码
don't worry you'll find this code in the code bundle

332
00:12:04,300 --> 00:12:05,400
所以让我们来看看
so let's walk through it

333
00:12:05,400 --> 00:12:07,033
我们提供了相同的模块
we've got the same module served at

334
00:12:07,033 --> 00:12:10,166
http server 然后我们启动这个函数
http server and then we have this function start

335
00:12:10,166 --> 00:12:11,166
我们把它命名为开始
we name it start

336
00:12:11,166 --> 00:12:13,666
而不是像示例代码中那样使用服务器
rather than server as they did in the example code

337
00:12:13,900 --> 00:12:16,200
这只是在给定端口上启动服务器
and this just starts the server on the given port

338
00:12:16,200 --> 00:12:17,333
本地主机
of local host

339
00:12:17,366 --> 00:12:18,833
我们在这里使用了一个保护子句
and we've used a guard clause here

340
00:12:18,833 --> 00:12:20,633
确保端口是整数
to make sure the port is an integer

341
00:12:20,800 --> 00:12:21,233
和
and

342
00:12:21,233 --> 00:12:23,900
并且端口号在十点二十三以上
also that the port number is above ten twenty three

343
00:12:24,166 --> 00:12:26,566
那是因为端口 0 到 10 23
and that's because ports zero through ten twenty three

344
00:12:26,833 --> 00:12:28,400
为操作系统保留
are reserved for the operating system

345
00:12:28,733 --> 00:12:30,966
所以我们需要一个十点二十三以上的港口
so we need a port above ten twenty three

346
00:12:31,200 --> 00:12:33,100
我们使用了守卫爪来强制执行
and we've used the guard claws to enforce that

347
00:12:33,666 --> 00:12:35,766
那么发生的第一件事就是我们调用listen
then the first thing that happens is we call listen

348
00:12:35,766 --> 00:12:37,433
就像我们在示例中所做的那样
just like we did in the example

349
00:12:37,566 --> 00:12:39,100
它会创建一个套接字
and it's going to create a socket to

350
00:12:39,100 --> 00:12:40,733
监听客户端连接
listen for client connections

351
00:12:41,066 --> 00:12:43,300
所以这个监听套接字变量是绑定的
and so this listen socket variable is bound

352
00:12:43,333 --> 00:12:44,766
到监听套接字
to the listening socket

353
00:12:45,000 --> 00:12:45,833
正如我们之前看到的
as we saw before

354
00:12:45,833 --> 00:12:47,733
监听端口有两个参数
listen takes two arguments the port

355
00:12:47,733 --> 00:12:49,800
然后是选项列表
and then a list of options

356
00:12:50,000 --> 00:12:52,233
所以这类似于我们之前的选项
so this is similar to the options we had before

357
00:12:52,566 --> 00:12:53,966
但我们改变了其中的几个
but we've changed a couple of these

358
00:12:53,966 --> 00:12:56,033
那么这些选项实际上意味着什么
so what do these options actually mean

359
00:12:56,166 --> 00:12:58,200
我们不必真正担心这些细节
we don't have to really worry about these details

360
00:12:58,200 --> 00:12:59,000
因为你会用
because you'll use

361
00:12:59,000 --> 00:13:00,966
不同场景下的不同选择
different options in different scenarios

362
00:13:00,966 --> 00:13:02,133
但是让我们来看看这些
but let's walk through these

363
00:13:02,700 --> 00:13:03,966
这个二元期权
this binary option

364
00:13:03,966 --> 00:13:06,700
表示我们要以二进制模式打开套接字
means we want to open the socket in binary mode

365
00:13:06,766 --> 00:13:08,833
并将数据作为二进制文件交付
and deliver data as binaries

366
00:13:09,333 --> 00:13:11,866
然后第二个选项是这个数据包原始
and then the second option is this packet raw

367
00:13:12,200 --> 00:13:15,000
这意味着我们希望将整个二进制文件交付给我们
which means we want the entire binary deliver to us

368
00:13:15,366 --> 00:13:18,133
没有在幕后发生任何数据包处理
without any packet handling happening behind the scenes

369
00:13:18,600 --> 00:13:20,766
然后我们有这个活动的假
then we have this active false which

370
00:13:20,766 --> 00:13:23,266
意味着我们想在准备好时接收数据
means we want to receive data when we're ready

371
00:13:23,366 --> 00:13:25,266
通过调用 g 接收
by calling g receive

372
00:13:25,266 --> 00:13:26,733
我们马上就会看到
which we'll look at in just a minute

373
00:13:27,066 --> 00:13:28,333
最后我们有了这个
and then finally we have this

374
00:13:28,333 --> 00:13:30,133
重用地址设置为真
reused address set to true

375
00:13:30,366 --> 00:13:32,666
这意味着我们希望允许重用
which means we want to allow reusing the

376
00:13:32,666 --> 00:13:34,533
监听器崩溃时的地址
address if the listener crashes

377
00:13:34,900 --> 00:13:37,200
这些是简单的标准选项
and these are pretty standard options for a simple

378
00:13:37,200 --> 00:13:40,033
然后我们打印出我们正在监听的网络服务器
web server then we print out that we're listening for

379
00:13:40,033 --> 00:13:41,800
该端口上的连接
connections on that port

380
00:13:42,333 --> 00:13:44,400
然后我们进入except循环
and then we drop into the except loop

381
00:13:44,600 --> 00:13:46,800
所以这只是一个名为 except 循环的函数
so this is just a function called except loop

382
00:13:46,833 --> 00:13:49,066
我们将监听套接字传递给它
we pass it the listen socket

383
00:13:49,166 --> 00:13:51,100
这将接受客户端连接
and this is going to accept client connections

384
00:13:51,100 --> 00:13:52,400
在这个监听套接字上
on this listen socket

385
00:13:52,766 --> 00:13:53,333
我们打印出来
we print out that

386
00:13:53,333 --> 00:13:55,300
我们正在等待接受客户端连接
we're waiting to accept a client connection

387
00:13:55,566 --> 00:13:56,466
然后我们打电话
and then we call

388
00:13:56,466 --> 00:13:59,166
就像我们在前面的示例代码中看到的一样接受
accept just like we saw in the example code earlier

389
00:13:59,700 --> 00:14:01,033
记住它暂停或
remember it suspends or

390
00:14:01,033 --> 00:14:03,366
阻塞并等待客户端连接
blocks and waits for a client connection

391
00:14:03,700 --> 00:14:05,400
以及何时接受该连接
and when that connection is accepted

392
00:14:05,566 --> 00:14:07,400
然后这个客户端套接字被绑定
then this client socket is bound

393
00:14:07,633 --> 00:14:09,300
到新的客户端套接字
to the new client socket

394
00:14:09,766 --> 00:14:10,033
那么那么
so then

395
00:14:10,033 --> 00:14:12,133
我们刚刚宣布连接被接受
we just pronounced that the connection was accepted

396
00:14:12,300 --> 00:14:14,066
然后我们称这个函数为serve
and then we call this function serve

397
00:14:14,366 --> 00:14:16,233
它将接收请求
which is going to receive the request

398
00:14:16,566 --> 00:14:19,466
关闭该客户端套接字并发送回响应
off that client socket and send a response back

399
00:14:19,566 --> 00:14:20,833
通过该客户端套接字
over that client socket

400
00:14:21,266 --> 00:14:22,866
一旦返回
and once this returns

401
00:14:22,866 --> 00:14:24,800
然后我们将再次调用接受循环
then we're going to call accept loop again

402
00:14:24,866 --> 00:14:27,366
递归循环到这里
recursively to loop back up here

403
00:14:27,366 --> 00:14:29,666
并等待下一个客户端连接
and wait for the next client connection

404
00:14:30,200 --> 00:14:32,200
所以让我们深入研究这个服务功能
so let's dive into this serve function

405
00:14:33,166 --> 00:14:35,433
好吧，这里需要客户端套接字
well it takes the client socket here

406
00:14:36,066 --> 00:14:37,566
将其输入芦苇请求
pipes it into reed request

407
00:14:37,766 --> 00:14:40,033
这将把请求作为字符串返回
that's going to return the request as a string

408
00:14:40,366 --> 00:14:41,000
然后我们管它
then we pipe it

409
00:14:41,000 --> 00:14:43,466
在这个函数中生成响应，所以我们生成一个
in this function generate response so we generate a

410
00:14:43,466 --> 00:14:45,100
有效的 http 响应
valid http response

411
00:14:45,266 --> 00:14:47,300
然后我们通过管道将其转化为正确的响应
and then we pipe it into right response

412
00:14:47,300 --> 00:14:48,333
把它写回来
to write it back out

413
00:14:48,333 --> 00:14:49,500
通过该客户端套接字
over that client socket

414
00:14:50,000 --> 00:14:53,300
读取请求非常简单，它调用 gnpc 接收
read request is pretty simple it calls gnpc receive

415
00:14:53,600 --> 00:14:55,633
在该客户端套接字上传入零
on that client socket passing in zero

416
00:14:55,633 --> 00:14:57,533
这意味着我们想要所有可用的食物
which means we want all the available bites

417
00:14:57,766 --> 00:14:57,933
然后
then

418
00:14:57,933 --> 00:14:59,666
请求将绑定到这个变量
the request is going to get bound to this variable

419
00:14:59,666 --> 00:15:02,533
我们从这里函数返回的请求
request which we return from this function here

420
00:15:03,466 --> 00:15:05,300
所以返回的是我们的请求字符串
so the return of this is our request string

421
00:15:05,300 --> 00:15:07,400
然后我们通过管道生成响应
which we then pipe into generate response

422
00:15:08,166 --> 00:15:09,566
生成响应只返回这个
generate response just returns this

423
00:15:09,566 --> 00:15:10,966
通用 http 响应
generic http response

424
00:15:10,966 --> 00:15:11,700
你注意到我们实际上是
you notice we're actually

425
00:15:11,700 --> 00:15:14,100
忽略这里的请求，因为我们真的不在乎
ignoring the request here because we don't really care

426
00:15:14,333 --> 00:15:15,566
我们只是生成一个
we're just generating a

427
00:15:15,766 --> 00:15:17,300
听到码头返回
hear dock to return

428
00:15:17,466 --> 00:15:20,000
一个有效的 http 响应，只是说你好
a valid http response that just says hello

429
00:15:20,633 --> 00:15:22,533
以便返回响应
so that returns the response

430
00:15:22,766 --> 00:15:25,133
在这里得到正确的回应
here which gets piped into right response

431
00:15:25,700 --> 00:15:26,733
如果我们看看那个
if we have a look at that

432
00:15:27,033 --> 00:15:29,000
它在客户端套接字中接收响应
it takes the response in a client socket

433
00:15:29,666 --> 00:15:31,200
调用 gntc 发送
calls gntc send

434
00:15:31,533 --> 00:15:34,100
在那个客户端套接字上给它响应
on that client socket giving it the response

435
00:15:34,266 --> 00:15:35,700
我们假设这是成功的
and we assume that that's successful

436
00:15:35,700 --> 00:15:37,166
所以我们将其模式匹配到好的
so we pattern match it to okay

437
00:15:37,500 --> 00:15:39,333
我们说嘿我们发回了回复
we say hey we sent the response back

438
00:15:39,666 --> 00:15:41,866
然后我们关闭了那个客户端套接字
and then we closed that client socket

439
00:15:42,566 --> 00:15:43,766
所以然后备份到这里
so then back up here

440
00:15:44,866 --> 00:15:48,133
这里的管道完成了，这就是服务部分
this pipeline here is done that's the serve part

441
00:15:48,466 --> 00:15:49,633
这返回
this returns

442
00:15:49,633 --> 00:15:52,600
然后我们循环回来在这里接受循环
and then we loop back up to accept loop here

443
00:15:53,033 --> 00:15:54,366
这让我们回到了这里
which takes us back up here

444
00:15:54,433 --> 00:15:56,900
我们正在等待下一个客户端连接
and we're waiting for the next client connection

445
00:15:57,466 --> 00:15:58,966
所以这基本上就是我们所看到的
so this is basically what we saw

446
00:15:58,966 --> 00:16:00,266
在前面的例子中，我们
in the early example we

447
00:16:00,266 --> 00:16:01,433
超越较早
transcended earlier

448
00:16:01,633 --> 00:16:02,400
我们刚刚添加了一堆
we just added a bunch

449
00:16:02,400 --> 00:16:04,300
评论和一些打印声明
of comments and some print statements

450
00:16:04,300 --> 00:16:05,833
展示正在发生的事情
to demonstrate what's happening

451
00:16:06,300 --> 00:16:07,200
我们还添加了部分
we also added the part

452
00:16:07,200 --> 00:16:09,400
它在哪里发送有效的 hdp 响应
where it sends a valid hdp response

453
00:16:09,400 --> 00:16:09,900
退出
back out

454
00:16:09,900 --> 00:16:11,033
通过客户端套接字
over the client socket

455
00:16:11,333 --> 00:16:12,100
另一个重要的
the other important

456
00:16:12,100 --> 00:16:14,166
我们所做的改变是我们递归调用
change we made is that we recursively call

457
00:16:14,166 --> 00:16:17,433
接受循环，以便服务器可以继续接受
accept loops so the server can continue to accept

458
00:16:17,433 --> 00:16:18,933
新的连接请求
new connection requests

459
00:16:19,500 --> 00:16:22,100
现在让我们使用这个版本的代码进行旋转，我
now let's take this version of our code for spin and I

460
00:16:22,133 --> 00:16:22,933
X
x

461
00:16:24,633 --> 00:16:26,600
这是调查高清服务器
it's survey hd server

462
00:16:26,666 --> 00:16:29,200
我们调用了我们的函数 start 并且它需要一个端口
we called our function start and it takes a port

463
00:16:29,366 --> 00:16:31,133
我将使用端口 4000
I'm going to use port 4000

464
00:16:31,566 --> 00:16:33,600
你可以使用任何你想要的超过十个端口
you can use whatever port you want above ten

465
00:16:33,600 --> 00:16:34,400
二十三
twenty three

466
00:16:35,133 --> 00:16:36,100
好的，它启动了
okay it starts up

467
00:16:36,333 --> 00:16:38,600
我们看到它正在监听连接请求
and we see that it's listening for connection requests

468
00:16:38,600 --> 00:16:39,966
在端口 4000
on port 4000

469
00:16:40,200 --> 00:16:43,033
它正在等待接受下一个客户端连接
and it's waiting to accept the next client connection

470
00:16:43,133 --> 00:16:45,566
那就是那个阻塞电话，除了那里
that's that blocking call except right there

471
00:16:46,000 --> 00:16:48,166
所以现在如果我们浏览到本地主机
so now if we browse over to local host

472
00:16:48,166 --> 00:16:49,666
4000 那是我们的港口
4000 that's our port

473
00:16:49,733 --> 00:16:51,366
我要做斜线熊
I'm going to do slash bears

474
00:16:52,000 --> 00:16:55,100
看看我们得到你好这是我们的一般反应
look at that we get hello that's our generic response

475
00:16:55,800 --> 00:16:57,966
如果我们向上滚动，则返回 ix
and back over an ix if we scroll up

476
00:16:59,433 --> 00:17:00,700
它就在这里等着
it was waiting right here

477
00:17:00,800 --> 00:17:02,466
但是当我们发送请求时
but then when we sent the request in

478
00:17:02,733 --> 00:17:04,200
连接被接受
the connection was accepted

479
00:17:04,366 --> 00:17:07,733
它在这里收到了这个关于斜线熊的请求
it received this request right here for slash bears

480
00:17:08,033 --> 00:17:10,033
所以这是完整的http请求
so here's the full http request

481
00:17:10,900 --> 00:17:12,833
然后它把响应发回
and then it sent the response back out

482
00:17:12,833 --> 00:17:14,333
我们在这里的一般回应
our generic response here

483
00:17:14,833 --> 00:17:15,966
然后它掠夺回来
and then it loot back up

484
00:17:16,000 --> 00:17:17,800
它正在等待下一个客户端连接
and it's waiting for the next client connection

485
00:17:18,366 --> 00:17:21,066
很酷，所以我们的通用 http 服务器正在运行
cool so our generic http server is going

486
00:17:21,066 --> 00:17:22,833
通过所有正确的动作
through all the correct motions

487
00:17:23,233 --> 00:17:26,200
现在我们需要做的就是插入我们的请求处理程序
now all we need to do is plug in our request handler

488
00:17:26,233 --> 00:17:27,366
进入这个管道
into this pipeline

489
00:17:27,466 --> 00:17:30,433
所以不要在这里生成通用响应
so instead of generating a generic response right here

490
00:17:30,566 --> 00:17:32,033
我们想打电话调查
we want to call survey

491
00:17:32,433 --> 00:17:34,100
把手把手
handle handle

492
00:17:34,600 --> 00:17:35,466
所以会发生什么
so what's going to happen

493
00:17:35,533 --> 00:17:36,266
被读取
is read

494
00:17:36,266 --> 00:17:36,766
要求
request

495
00:17:36,766 --> 00:17:39,033
将从客户端套接字获取请求
is going to get the request from the client socket

496
00:17:39,133 --> 00:17:41,033
然后它将通过管道传输该字符串
then it's going to pipe that string

497
00:17:41,133 --> 00:17:42,433
进入我们的句柄函数
into our handle function

498
00:17:42,533 --> 00:17:44,833
它将响应作为字符串返回
which returns the response as the string

499
00:17:45,100 --> 00:17:47,100
然后将该响应字符串通过管道传输到
and that response string is then piped into

500
00:17:47,100 --> 00:17:48,133
正确的反应
right response

501
00:17:48,200 --> 00:17:50,000
它将响应发送回
which sends the response back out

502
00:17:50,000 --> 00:17:51,100
通过客户端套接字
over the client socket

503
00:17:51,433 --> 00:17:52,266
换句话说
in other words

504
00:17:52,266 --> 00:17:54,366
我们已经将处理程序包裹在一个薄薄的
we've wrapped our handler in a thin

505
00:17:54,366 --> 00:17:55,833
允许的套接字层
socket layer that lets

506
00:17:55,833 --> 00:17:59,133
与我们服务器的任何 http 客户端接口
any http client interface with our server

507
00:17:59,600 --> 00:18:00,733
所以让我们再运行一次
so let's run this again

508
00:18:00,900 --> 00:18:02,633
现在我的性爱会议挂了
now my sex session is hung

509
00:18:02,633 --> 00:18:04,266
因为它正在等待客户端连接
because it's waiting for a client connection

510
00:18:04,300 --> 00:18:05,200
所以我要
so I'm just going to

511
00:18:05,200 --> 00:18:06,633
控制 c 两次以摆脱它
control c twice to get out of that

512
00:18:07,200 --> 00:18:09,066
并重新启动 ix
and start ix back up again

513
00:18:09,666 --> 00:18:12,000
然后我们将再次在端口 4000 上启动我们的服务器
then we'll start our server on port 4000 again

514
00:18:12,600 --> 00:18:14,300
好的，它正在等待客户端连接
okay it's waiting for a client connection

515
00:18:14,866 --> 00:18:17,366
reload 本地主机 4000 斜线熊
reload local host 4000 slash bears

516
00:18:17,733 --> 00:18:20,000
看看我们得到了所有熊的列表
and look at that we get a list of all of the bears

517
00:18:20,366 --> 00:18:22,766
很酷，所以现在我们知道它正在调用我们的处理程序
cool so now we know it's calling our handler

518
00:18:23,433 --> 00:18:25,133
所以它可以在他们的浏览器上运行，但现在
so it works on their browser but now

519
00:18:25,300 --> 00:18:27,933
任何 http 客户端都可以与我们的 Web 服务器交互
any http client can interface with our web server

520
00:18:28,100 --> 00:18:28,533
实际上
in fact

521
00:18:28,533 --> 00:18:31,033
我们可以使用 curl 命令行客户端发送一个
we can use the curl command line client to send an

522
00:18:31,033 --> 00:18:34,133
api 请求所以我只是在一个新的终端会话中
api request so I'm just in a new terminal session here

523
00:18:34,133 --> 00:18:35,200
我将使用 curl
I'm going to use curl

524
00:18:35,366 --> 00:18:39,000
然后我要给它 http 本地主机 4000 api
and then I'm going to give it http local host 4000 api

525
00:18:39,066 --> 00:18:42,766
斜线熊，我们得到一个熊的json列表
slash bears and we get back a json list of bears

526
00:18:42,966 --> 00:18:43,933
这很甜蜜
that's pretty sweet

527
00:18:44,600 --> 00:18:45,300
自从伯爵
since earling has

528
00:18:45,300 --> 00:18:46,633
已经存在了几十年
been around for decades

529
00:18:46,633 --> 00:18:50,066
它有大量经过验证的真实库
it has an extensive set of tried and true libraries

530
00:18:50,233 --> 00:18:52,066
这是值得牢记的
this is something worth keeping in mind

531
00:18:52,300 --> 00:18:55,466
如果您没有找到适合您需求的长生不老药库
if you don't find an elixir library to suit your needs

532
00:18:55,500 --> 00:18:57,200
寻找伯爵图书馆
look for an earling library

533
00:18:57,333 --> 00:18:59,666
可能性是如果它是通用需求
odds are if it's a general purpose need

534
00:18:59,833 --> 00:19:02,066
有人已经写了一个库
somebody has already written a library

535
00:19:02,433 --> 00:19:03,566
现在你知道如何使用了
and now you know how to use

536
00:19:03,666 --> 00:19:05,733
长生不老药包装中的任何统治图书馆
any ruling library in your elixir wrap

