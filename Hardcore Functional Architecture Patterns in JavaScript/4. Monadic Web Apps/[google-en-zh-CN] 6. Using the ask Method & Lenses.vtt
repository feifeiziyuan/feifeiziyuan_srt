WEBVTT

1
00:00:00.210 --> 00:00:02.963
你们都是镜片吧？
Lenses y'all, right?

2
00:00:02.963 --> 00:00:03.580
让我们把那些人带进来。
Let's bring those in.

3
00:00:04.830 --> 00:00:10.767
所以带上镜头道具，然后
So bring in a lens prop, And

4
00:00:10.767 --> 00:00:16.212
超过n，让我们也被移除销毁，因为我喜欢，
over of n, let's also get removed for destroy because I like,

5
00:00:16.212 --> 00:00:20.748
我不必做这些奇怪的拼接之类的。
I don't have to do these weird splices and whatnot.

6
00:00:20.748 --> 00:00:25.125
我们会来的，我们会从 lamda 那里得到那个，所以
We'll come we'll get that from lamda, so

7
00:00:25.125 --> 00:00:29.753
现在在创建我们可以说，事实追加数组。
now on create we can say, fact append array.

8
00:00:29.753 --> 00:00:35.990
所以我们可以做over state，我们需要为习惯做一个镜头道具。
So we can do over state and we need to make a lens prop for the habits.

9
00:00:35.990 --> 00:00:41.387
这就是我们想要改变正确的 elda 习惯，开销习惯。
That's what we want to change right elda habits, overhead habits.

10
00:00:41.387 --> 00:00:45.940
我们要对最后一个论点表示抱歉。
We want to sorry states the last argument.

11
00:00:45.940 --> 00:00:50.750
我们要附加习惯。
We want to append the habit.

12
00:00:50.750 --> 00:00:54.011
酷，忘记了一点。
Cool, forgot a little.

13
00:00:54.011 --> 00:00:56.921
让我们继续制作我们的小镜头命名空间
And let's go ahead and make our little lens namespace and

14
00:00:56.921 --> 00:00:59.670
我们可能只需要考虑到这一点。
we could probably just do this in mind.

15
00:00:59.670 --> 00:01:07.181
然而习惯和那将是lensProp，习惯。
Yet habits and that will be lensProp, Habit.

16
00:01:08.904 --> 00:01:12.242
很酷，关于这个自动完成的小东西的一件事，
Cool, one thing about this little autocomplete thing,

17
00:01:12.242 --> 00:01:16.570
它告诉我我实际上是正确导入的，所以这很好。
it tells me I actually imported it right, so that's nice.

18
00:01:16.570 --> 00:01:19.512
很酷，所以我们都看到了它是如何工作的。
Cool, so we all see how that works.

19
00:01:19.512 --> 00:01:24.834
让我们看看这是否通过 a, b 根本不起作用。
Let's see if that goes through a, b not working at all.

20
00:01:24.834 --> 00:01:27.432
[笑]好吧，这里发生了什么？
[LAUGH] All right, what's happening here?

21
00:01:27.432 --> 00:01:32.094
所以我们说的是习惯，附加习惯。
So we're saying over the habits, append the habit.

22
00:01:32.094 --> 00:01:36.846
你认为这应该有效吗，所以
And do you believe that should work, so

23
00:01:36.846 --> 00:01:39.875
有人看到任何问题吗？
anybody see any issues?

24
00:01:39.875 --> 00:01:41.734
&gt;&gt; 养成习惯。
&gt;&gt; Structure the habit.

25
00:01:41.734 --> 00:01:44.476
&gt;&gt; 在您自己的镜头道具中养成习惯。
&gt;&gt; Habits in your own lensprop.

26
00:01:44.476 --> 00:01:46.811
&gt;&gt; 谢谢，就是这样。
&gt;&gt; Thank you that's it.

27
00:01:46.811 --> 00:01:52.555
好 ib，c 真好。
Good i b, c it's so nice.

28
00:01:52.555 --> 00:01:57.481
好吧，如果我破坏，让我们摆脱清除整个事情，
All right and if I destroy let's get rid of cleared the whole thing out,

29
00:01:57.481 --> 00:01:59.055
我是故意这样做的。
I did that on purpose.

30
00:01:59.055 --> 00:02:01.051
[笑]好吧。
[LAUGH] All right.

31
00:02:01.051 --> 00:02:05.804
所以让我们用镜头做同样的事情，为什么不呢？
So let's do the same thing with lenses why not

32
00:02:05.804 --> 00:02:10.683
过习惯删除 ID x 删除一个是删除
over habits remove the ID x remove one is remove

33
00:02:10.683 --> 00:02:15.700
基本上就像拼接或状态流量。
is basically like splice or the state traffic.

34
00:02:15.700 --> 00:02:21.288
然后运行这个 a、b 和 c 的实际属性，
And then were run this a, b and c the actual property,

35
00:02:21.288 --> 00:02:26.679
很酷的字母 b，所以我们做得很好，我们很高兴。
cool letter b, so we're doing great, we're very happy.

36
00:02:26.679 --> 00:02:31.076
我们正在使用 Montes，我们得到了所有的东西，但是
We're using Montes, we got all the stuffs but

37
00:02:31.076 --> 00:02:35.585
令我烦恼的一件事是每次
one thing that kind annoying me is that each time

38
00:02:35.585 --> 00:02:39.772
我们不得不说，我该怎么说？
we're having to kind of, how do I say this?

39
00:02:39.772 --> 00:02:45.060
我们必须处理这种状态并进行管理，比如添加它。
We have to deal with this state and managing, like adding to it.

40
00:02:45.060 --> 00:02:48.934
如果相反，我们真的回来了，
What if instead, we actually returned,

41
00:02:48.934 --> 00:02:53.813
我们刚刚返回了一个状态，它刚刚为我们合并了它。
we just returned a state and it just merged it for us.

42
00:02:53.813 --> 00:02:57.260
我们不必处理合并这些东西，对吧？
We didn't have to deal with merging this stuff, right?

43
00:02:58.800 --> 00:03:03.864
所以这个对象分配例如说我有一个状态和
So this object assign for instance is saying I have a state and

44
00:03:03.864 --> 00:03:08.728
当我们添加新操作时，您是我们应用程序的开发者
it's on you as a developer of our app, as we add new actions

45
00:03:08.728 --> 00:03:13.517
随着时间的推移，始终确保您将状态合并回。
over time to always make sure you merge the state back in.

46
00:03:13.517 --> 00:03:20.820
如果你可以只返回 merge 并且它是一个幺半群会怎样。
What if you could just return merge and it's a monoid.

47
00:03:20.820 --> 00:03:23.555
是的，风的幺半群，所以
Right, monoids for the wind, so

48
00:03:23.555 --> 00:03:29.233
现在我不必担心实际对象分配我的状态。
now I don't have to worry about actually object assigning my state.

49
00:03:29.233 --> 00:03:30.740
让我们在那里创建一个幺半群。
Let's make a monoid there.

50
00:03:30.740 --> 00:03:35.970
我们在这里做同样的事情，只是在这里出现和出现。
We do the same thing here, just emerge and emerge here.

51
00:03:35.970 --> 00:03:40.890
所以这将要做的只是合并，与镜头，不是那么大
And so what this is gonna do is just merge, with the lenses, not such a big

52
00:03:40.890 --> 00:03:43.510
处理我们只是打开状态改变一些东西的地方
deal where we're just opening up the state changing something and

53
00:03:43.510 --> 00:03:46.700
返回整个状态，因此合并不会在这里购买太多，但在这里，
returning a whole state back so the merge doesn't buy as much here, but down here,

54
00:03:46.700 --> 00:03:50.300
它很像我们只是改变了一点状态。
it does a lot like we're just turning a little bit of state.

55
00:03:50.300 --> 00:03:52.550
它将为我们将其合并回状态。
It will merge that back into the state for us.

56
00:03:52.550 --> 00:03:55.380
随着我们建造的越来越多，我们不必总是担心
And as we build more, we don't have to worry about always

57
00:03:55.380 --> 00:03:58.280
管理整个状态结构而不是破坏它。
managing this whole state structure and not breaking it.

58
00:03:58.280 --> 00:04:02.487
我们可以只退还我们关心的那一小块
We could just return the little piece that we care about

59
00:04:02.487 --> 00:04:05.238
每个人都有这个想法。
everybody on board with this idea.

60
00:04:05.238 --> 00:04:06.719
好吧，让我们继续合并。
All right, let's go ahead and make a merge.

61
00:04:07.880 --> 00:04:13.038
回到我们今天的第一件事幺半群。
Back to our very first thing of the day monoids.

62
00:04:13.038 --> 00:04:17.637
我们只会说我会暴露 X 并且我们会说，
And we'll just say I will expose the X and we'll concat that by saying,

63
00:04:17.637 --> 00:04:18.952
获得另一个合并。
get another merge.

64
00:04:18.952 --> 00:04:24.890
我们总是保持关闭，对象分配，制作一个漂亮的副本，所以我们不会破坏任何东西。
We always stay closed, object assign, make a nice copy, so we don't break anything.

65
00:04:24.890 --> 00:04:28.620
也许我们可以回去尝试检查并确保它的性能超级好
Maybe we can go back and try to check and make sure it's super performing and

66
00:04:28.620 --> 00:04:32.240
摆脱这个，但目前，我们只是为了安全起见
get rid of this but at the moment, we're just gonna be on the safe side and

67
00:04:32.240 --> 00:04:33.630
制作一个漂亮的小副本。
make a nice little copy.

68
00:04:33.630 --> 00:04:38.740
我们会说其他 .x，所以我们正在合并我们的 x
And we'll say other .x, so we're merging our x

69
00:04:38.740 --> 00:04:43.593
与另一个 x 含义加上一个合并一个 1，
with another x meaning plus a merge a 1,

70
00:04:43.593 --> 00:04:50.060
concat 合并一个 2，
concat merge a 2,

71
00:04:50.060 --> 00:04:54.180
我想我希望正确的人获胜，所以这是有道理的。
I think I want the right one to win, so that makes sense.

72
00:04:54.180 --> 00:04:58.360
这个会覆盖这个，就像我们如何定义它，所以工作。
This one's gonna overwrite this one, just how we're defining it, so work.

73
00:04:59.470 --> 00:05:05.835
看看会发生什么，也许我们会翻转它，但是我们走了，所以我们进行了合并。
See what happens, maybe we'll flip that, but there we go, so we get a merge.

74
00:05:05.835 --> 00:05:12.323
现在我必须去更新我们的主应用程序循环，对吗？
Now I have to go update our main app loop now, right?

75
00:05:12.323 --> 00:05:16.310
让我们继续吧，去掉这些让我丧命的花括号。
Let's go ahead and just get rid of these curly braces killing me.

76
00:05:16.310 --> 00:05:21.033
[笑] 如果你看到我写花括号和函数然后返回，
[LAUGH] If you ever see me write curly braces and a function and return,

77
00:05:21.033 --> 00:05:23.078
我精神状态不好。
I'm in a bad space mentally.

78
00:05:23.078 --> 00:05:26.516
[笑] 所以，我们在这里，我们在这个事件循环中
[LAUGH] So, here we are, we're in this event loop and

79
00:05:26.516 --> 00:05:30.830
正如我们现在所说的这些函数返回一个淹没，对。
as we call these functions now the returning a submerge, right.

80
00:05:32.130 --> 00:05:39.630
所以我们要做的是得到我们想要开始的状态
So what we'll have to do is get the state we wanna start with emerge of state

81
00:05:39.630 --> 00:05:44.730
将其与出现的任何返回值连接起来。
working concat that with whatever this returns which is emerge.

82
00:05:46.110 --> 00:05:49.560
然后好吧，concats 这就是整件事，
And then okay that concats It there's the whole thing,

83
00:05:49.560 --> 00:05:52.610
我们不会在这里通过合并。
and we're not gonna pass a merge here.

84
00:05:52.610 --> 00:05:54.230
所以让我们把它从合并中弹出，
So let's just pop it out of the merge,

85
00:05:54.230 --> 00:05:59.080
弄出来就行了，在我们做完操作之后把它从x的类型里弄出来。
just get it out, get it out of the type of the x after we do the operation.

86
00:05:59.080 --> 00:06:01.887
大家看看效果如何？
Everybody see how that works?

87
00:06:01.887 --> 00:06:04.691
我们要合并这两个状态，所以
We're gonna merge the two states, so

88
00:06:04.691 --> 00:06:09.560
这将返回对每一个的合并，然后我们将其取出。
this returns a merge on each of these and then we take it out.

89
00:06:09.560 --> 00:06:13.170
太好了，它仍在工作。
Great, it's still working.

90
00:06:13.170 --> 00:06:14.090
那个怎么样？
How about that?

91
00:06:14.090 --> 00:06:16.960
然后我们点击 B，它显示 B，万岁。
And we click B, and it's showing B, hooray.

92
00:06:16.960 --> 00:06:21.840
我已经不喜欢的一件事是我必须到处调用合并，所以
One thing I don't like already is that I have to call merge everywhere, so

93
00:06:21.840 --> 00:06:22.840
让我们考虑一下。
let's factor that out.

94
00:06:22.840 --> 00:06:27.977
让我们把它放回我们的事件循环中，它将摆脱这些
Let's put that back down into our event loop will get it out of these

95
00:06:27.977 --> 00:06:33.760
这些小函数现在只返回一点点状态
these little functions that are just returning little bits of state now and

96
00:06:33.760 --> 00:06:37.271
他们都被合并了，不是很好。
they're all being merged, not super nice.

97
00:06:37.271 --> 00:06:41.400
所以我们只是把它合并在这里，很酷。
So we'll just put this in a merge down here, cool.

98
00:06:41.400 --> 00:06:44.424
它有点失控了。
It's getting a little bit out of control.

99
00:06:44.424 --> 00:06:48.320
让我们继续[笑]，暂时这样做。
Let's go ahead [LAUGH] and do that or something for the time being.

100
00:06:49.390 --> 00:06:51.300
好的，我们将在这里连接这两个，
All right, and we'll concat these two right here,

101
00:06:51.300 --> 00:06:55.120
我们会得到 x，我们就这样。
and we'll get the x, there we go.

102
00:06:55.120 --> 00:06:58.970
所以它有点难看，我不会撒谎，但没关系。
So it's a little bit ugly, I'm not gonna lie, but that's fine.

103
00:06:58.970 --> 00:07:02.848
从概念上讲并不难看，这是很多嵌套。
Not ugly conceptually, that's a lot of nesting.

104
00:07:02.848 --> 00:07:07.042
但是在这里，当我们真正定义我们的函数时，看看它是多么干净。
But up here, when we're actually defining our functions, look how clean this is.

105
00:07:07.042 --> 00:07:10.082
我不知道你是否曾经使用过氧化还原，但是
I don't know if you've ever used redox, but

106
00:07:10.082 --> 00:07:14.644
到处都是 switch 语句，什么不是，好吗？
there's the littered with switch statements and what not, okay?

107
00:07:14.644 --> 00:07:19.704
我们知道每次都会传入状态。
We know that state gets passed in each time.

108
00:07:19.704 --> 00:07:21.506
我们知道我们可以翻转争论
And we know we can flip arguments around and

109
00:07:21.506 --> 00:07:23.420
我们可以使用读者来解决这个问题。
we can use readers to kind of factor that out.

110
00:07:23.420 --> 00:07:26.516
我注意到，我在这里没有使用状态，对吧？
And I noticed, I'm not using state down here, right?

111
00:07:26.516 --> 00:07:30.330
我只是忽略它，那为什么我每次都必须传递它？
I'm just ignoring it, so why do I have to pass it in every time?

112
00:07:30.330 --> 00:07:31.970
为什么我要处理它？
Why do I have to deal with it?

113
00:07:31.970 --> 00:07:34.274
现在他们只是返回了一点状态。
Now they just returned a little bits of state.

114
00:07:34.274 --> 00:07:40.055
我们只在想要绘制州地图时才要求它如何？
How do I how about we only ask for it when we want to map over the state and

115
00:07:40.055 --> 00:07:44.620
然后我们会看看这个结果有多好。
then we'll do look how nice this worked out.

116
00:07:44.620 --> 00:07:50.580
我可以抵消州的繁荣，繁荣。
I can cancel out the state's boom, boom.

117
00:07:50.580 --> 00:07:54.744
所以它只是传入状态的第一类函数。
So it's just a first class function that passes in the state.

118
00:07:54.744 --> 00:07:58.260
好吧，这很整洁，现在这只是一个需要习惯的函数。
All right, that's neat and now this is just a function that takes a habit.

119
00:07:59.520 --> 00:08:03.391
嘿看，那个函数就像一个普通的函数。
Hey look, that function is like a normal function.

120
00:08:03.391 --> 00:08:06.273
[笑] 不再是减速机了。
[LAUGH] It's not a reducer anymore.

121
00:08:06.273 --> 00:08:11.107
所以让我们继续为这些事情做，让我们摆脱这里的状态，然后
So let's go ahead and do that for these let's get rid of the state here and

122
00:08:11.107 --> 00:08:15.863
我们会在这里做完全相同的模式，我们会映射，我们会要求
we'll do the exact same pattern here, we'll map over, we'll ask for

123
00:08:15.863 --> 00:08:18.096
国家，我们会拿回来的。
the state and we'll get it back.

124
00:08:18.096 --> 00:08:22.825
然后在这里我们一起摆脱状态，我们甚至不必问
And then down here we get rid of the state all together, we don't even have to ask

125
00:08:22.825 --> 00:08:27.490
对于它，我们很好，好吧，我们如何实现它，对吗？
for it, we're fine, okay, how do we how do we implement that, right?

126
00:08:27.490 --> 00:08:31.360
好吧，我们必须马上被问到，所以
Well, we have to go get asked right off the bat, so

127
00:08:31.360 --> 00:08:37.500
让我们从我们的 lib 类型中获取一个函数，
let's get a function from our lib types,

128
00:08:39.300 --> 00:08:43.390
和功能已经问过所以只是从功能中询问。
and function has asked so just ask from function.

129
00:08:44.550 --> 00:08:49.640
太好了，然后我们将在这里使用函数来为我们的东西建模。
Great, and then we'll use functions down here to model our stuff.

130
00:08:49.640 --> 00:08:53.917
现在我可以把它包装在一个函数中，但是
Now I could wrap this in a function and all that, but

131
00:08:53.917 --> 00:08:59.505
我要说这是一个返回 FN 类型的函数，对吗？
I'm gonna say this is a function that returns the FN type, right?

132
00:08:59.505 --> 00:09:04.381
而这个我想我可以暂时把它放在那里
And this one I guess I could just put that right there just for now and

133
00:09:04.381 --> 00:09:07.790
说，好吧，好吧，我有那个功能。
say, okay, well, I have a function of that.

134
00:09:08.930 --> 00:09:15.270
我相信我们可以再次考虑这一点以回到那个状态，我还不确定。
I believe we can factor this out again to get back to that or not, I'm not sure yet.

135
00:09:15.270 --> 00:09:19.560
我们会弄清楚的，那么，我们在哪里？
We'll figure it out, so, where are we?

136
00:09:19.560 --> 00:09:22.160
现在不是将我们的函数称为状态，
Instead of calling our function a state now,

137
00:09:22.160 --> 00:09:25.560
我们只是被有效载荷抓住了，对吧？
we're just caught with the payload, right?

138
00:09:25.560 --> 00:09:30.150
但是然后我们用状态运行那个东西，它可以选择是否或
But then we run that thing with the state and it can choose whether or

139
00:09:30.150 --> 00:09:32.210
不是它想使用它。
not it wants to use it.

140
00:09:33.460 --> 00:09:36.540
好的，编译成功，看一下。
All right, compiled successfully, look at that.

141
00:09:36.540 --> 00:09:40.910
走到这里，a，b 看看那多好。
Going over here, a, b look how nice that is.

142
00:09:40.910 --> 00:09:43.919
我可以删除它，是的，我可以显示它，是的。
I could delete it, yep, I can show it, yep.

143
00:09:43.919 --> 00:09:48.556
很酷，好吧，现在我们可以从任何地方提取状态。
Cool, all right, so now we're able to just pull state out of nowhere.

144
00:09:48.556 --> 00:09:53.940
[笑] 而且，作为回报，我们在这里要做的是说，
[LAUGH] And, in return little bits we're gonna do here is say,

145
00:09:53.940 --> 00:10:00.710
好吧，这个应用程序的结构可以不同，对吗？
all right again, the structure of this application can be different, right?

146
00:10:00.710 --> 00:10:03.950
我们可以将其提取到我们的应用程序循环中。
We can pull this out into our app loop.

147
00:10:05.160 --> 00:10:08.110
我们可以将所有这些东西拉到我们的控制器中。
We can pull all this stuff out into our controller.

148
00:10:09.170 --> 00:10:13.504
我们可以把它移到一个图书馆等
We can move this into a library and so

149
00:10:13.504 --> 00:10:18.170
我们不必在这里。
we don't have to here.

150
00:10:18.170 --> 00:10:21.544
老实说，我不在乎我们是，你知道，
And honestly, I don't care that we are, you know,

151
00:10:21.544 --> 00:10:26.377
达到了我想将它们移动到控制器和小模型中的地步
hit a point where I want to move those into a controller and a little model and

152
00:10:26.377 --> 00:10:31.008
实用程序库和我的主要功能，即应用程序循环。
utility libraries and my little main function, which is the app loop.

153
00:10:31.008 --> 00:10:34.060
但是你通常会看到很多这样的函数式程序，
But you typically see a lot of functional programs like this,

154
00:10:34.060 --> 00:10:36.490
因为这无所谓。
because it just doesn't matter.

155
00:10:36.490 --> 00:10:40.430
所以我认为它最终很重要，那就是你去做的时候。
And so I think it eventually matters and that's when you do it.
