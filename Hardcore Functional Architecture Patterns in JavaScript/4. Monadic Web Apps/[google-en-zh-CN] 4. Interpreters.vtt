WEBVTT

1
00:00:00.050 --> 00:00:03.939
在我移动这东西之前我会再花一秒钟
I will spend one more second before I shift this thing and

2
00:00:03.939 --> 00:00:05.600
转到下一个。
move on to the next one.

3
00:00:05.600 --> 00:00:10.640
除非你在我们继续之前有任何愿望。
Unless you have any wishes here before we move on.

4
00:00:10.640 --> 00:00:17.444
但是我们在这里还能做什么，我们实际上可以解决这个问题，对吗？
But what else we can do here we can actually step this out, right?

5
00:00:17.444 --> 00:00:19.050
所以我们可以进行解释器测试。
So we can interpreter test.

6
00:00:20.480 --> 00:00:24.170
可以在这里做 interpretTest，和
Could do interpretTest here, and

7
00:00:24.170 --> 00:00:29.040
而不是 dbToTask 怎么样 dbToId，对吧？
instead of dbToTask what about dbToId, right?

8
00:00:29.040 --> 00:00:31.399
代替 consoleToTask，consoleToId 怎么样？
Instead of consoleToTask, what about consoleToId?

9
00:00:31.399 --> 00:00:37.310
我们可以在这里编写一些函数。
And we could write a little couple functions here.

10
00:00:37.310 --> 00:00:43.581
所以我们有 consoleToTask，而不是实际的参数 ID，
So we have consoleToTask, where Instead of actually params ID,

11
00:00:43.581 --> 00:00:49.509
而不是实际阅读问题以获取输入，
instead of actually reading the question getting the input,

12
00:00:49.509 --> 00:00:54.411
我们可以说 Id of，这将是一个函数
we can say Id of, it's going to be a function here of

13
00:00:54.411 --> 00:00:58.645
不管问题是什么 q 说 q 的答案。
whatever the question was q say answer to q.

14
00:01:01.360 --> 00:01:04.510
好吧，别管我了。
All right, get this out of my way.

15
00:01:05.790 --> 00:01:07.980
对于在线的人来说，这一定是非常令人沮丧的。
It's gotta be horribly frustrating for people online.

16
00:01:07.980 --> 00:01:12.580
很抱歉这些弹出窗口到处都很酷。
Sorry about these pop-ups everywhere cool.

17
00:01:12.580 --> 00:01:13.930
所以有问题。
So there is question.

18
00:01:13.930 --> 00:01:19.995
让我用换句话说 [笑] 对一些实际的东西进行评级。
Let me actually break this out in other word [LAUGH] rating some actual stuff.

19
00:01:19.995 --> 00:01:25.239
这里的输出会发生什么，
And what's gonna happen here for the output,

20
00:01:25.239 --> 00:01:30.885
好吧，我有一些，我有一根绳子
this well, I've got some, I've got a string and

21
00:01:30.885 --> 00:01:34.952
我可以将字符串写为 Id。
I can do Id of writing the string as.

22
00:01:34.952 --> 00:01:39.330
好吧，继续这样做，记住我要进行插值
All right keep doing that, remember I'm gonna be interpolating so

23
00:01:39.330 --> 00:01:41.520
你可以看到发生了什么。
you could see what's going on.

24
00:01:41.520 --> 00:01:46.330
很酷，所以我们正在做的是，返回一个记录正在发生的事情的 ID。
Cool, so what we're doing is, returning an ID that kind of logs what's happening.

25
00:01:46.330 --> 00:01:48.140
它实际上并没有写入屏幕。
And it's not actually writing to the screen.

26
00:01:48.140 --> 00:01:49.430
我们正在取回数据。
We're getting data back.

27
00:01:49.430 --> 00:01:55.451
如果我们对Id做DB，我们也可以这样做
If we do DB to Id, we can do the same

28
00:01:55.451 --> 00:02:00.850
关于保存的事情，糟糕。
thing on save and an all oops.

29
00:02:00.850 --> 00:02:03.429
这需要我们的桌子两次。
And that takes our table both times.

30
00:02:05.970 --> 00:02:07.182
关于记录查询的提示。
Tip on a record query.

31
00:02:07.182 --> 00:02:10.295
然后再次，
And again,

32
00:02:10.295 --> 00:02:15.282
保存我们的桌子。
saving our table.

33
00:02:15.282 --> 00:02:20.238
在这里我们会找到所有
And here we'll finding all

34
00:02:20.238 --> 00:02:24.984
在带有查询的表中。
in the table with a query.

35
00:02:24.984 --> 00:02:30.868
太好了，看看我们的测试解释器会发生什么。
Great, see what happens here with our test interpreter.

36
00:02:30.868 --> 00:02:33.969
简直炸了
Just blows up.

37
00:02:33.969 --> 00:02:37.970
[笑] 我还在分叉。
[LAUGH] I'm still forking it.

38
00:02:37.970 --> 00:02:41.030
[笑] 所以我和我们只是要提取。
[LAUGH] So Id and we're just going to extract.

39
00:02:42.110 --> 00:02:45.860
然后从那里开始，我们将递归地运行
And then from there, we're going to run our recursively

40
00:02:45.860 --> 00:02:50.120
看看会发生什么。
on that and see what happens.

41
00:02:50.120 --> 00:02:52.037
埃迪不好，我得把它带进来。
Eddie's not fine, I gotta bring it in.

42
00:02:52.037 --> 00:02:54.490
嘘嘘。
Boo Boo.

43
00:02:54.490 --> 00:03:00.956
这是一天中的时间，这只是一次又一次的空气。
This is about the time of the day where this is just gonna be air after after air.

44
00:03:00.956 --> 00:03:07.980
F 不是函数和解释测试，只是不知道 f 在哪里。
F is not a function and interpretTest, just don't even know where f is.

45
00:03:07.980 --> 00:03:10.850
所以我们要运行它。
So we're gonna run that.

46
00:03:10.850 --> 00:03:15.210
我们回到，&gt;&gt; Ruby 启动和数据函数。
Are we back to, &gt;&gt; Ruby start and data function.

47
00:03:15.210 --> 00:03:19.400
&gt;&gt; 所以我们正在提取 Id 中的任何内容。
&gt;&gt; So we're extracting whatever is in the Id.

48
00:03:19.400 --> 00:03:23.700
记住在我们做出这个承诺之前，这些事情将会发生
And remember before we made this promise that these things were going to be

49
00:03:23.700 --> 00:03:30.450
返回就像，好吧，我认为他们正在返回延续的任务。
returning like, well, I think they're returning tasks of the continuation.

50
00:03:30.450 --> 00:03:33.390
当我们运行这些东西时
And as we run these things and

51
00:03:33.390 --> 00:03:38.940
链接这些东西，我们实际上正在运行和链接免费的 mon 广告，
chain these things, we're actually running and chaining the free mon ad,

52
00:03:38.940 --> 00:03:44.230
这被解释为另一种结果。
which is being interpreted into a different kind of result.

53
00:03:44.230 --> 00:03:46.900
所以应该仍然像 dbSave 和
So that should still hold like dbSave and

54
00:03:46.900 --> 00:03:51.110
现在所有这些都只是将它们变成了 ID。
all that is just turning them into Ids now.

55
00:03:51.110 --> 00:03:53.770
我想我只是，我现在很困惑 f 是什么。
I think I'm just, I'm confused what f is right now.

56
00:03:54.820 --> 00:03:58.200
这将是最后的小事。
This will be the last little thing.

57
00:03:58.200 --> 00:04:01.850
看看这个console.logf。
Just look at this console.logf.

58
00:04:01.850 --> 00:04:07.482
再一次，回到我应该把这个放在首位，对吧？
Once again, back to I should just left this in the first place, right?

59
00:04:07.482 --> 00:04:08.626
[声音] 好的，f 是什么？
[SOUND] Okay, what is f?

60
00:04:08.626 --> 00:04:13.230
F 是未定义的路由器路由。
F is undefined router route.

61
00:04:13.230 --> 00:04:14.330
我们走了。
There we go.

62
00:04:14.330 --> 00:04:15.117
看看发生了什么。
See what happened.

63
00:04:15.117 --> 00:04:19.691
我没有正确解释我的问题是答案和
I didn't interpret correctly on my question is the answer to and

64
00:04:19.691 --> 00:04:21.900
应该是路线
it's supposed to be a route.

65
00:04:21.900 --> 00:04:24.504
只是为了好玩，让我们做正确的事，让我们看看会发生什么。
Just for fun let's just do right let's see what happens.

66
00:04:24.504 --> 00:04:29.267
[声音] [笑] 炸毁了堆栈。
[SOUND] [LAUGH] Blew the stack.

67
00:04:29.267 --> 00:04:34.560
[笑]但你可以看到，它确实在解释它。
[LAUGH] But you can see, it is indeed interpreting it.

68
00:04:34.560 --> 00:04:37.270
我们只需要做更多的工作。
We just have to do a little bit more work arounds.

69
00:04:37.270 --> 00:04:41.380
好的，既然我们不去任务和做这个问答界面，
Okay, now that we're not going to task and doing this question answer interface,

70
00:04:41.380 --> 00:04:42.268
我该如何模拟。
how do I mock out.

71
00:04:42.268 --> 00:04:46.819
我想在我们关闭之前我接下来要做的是说好，
I think what I would do next before we shut this is to say well,

72
00:04:46.819 --> 00:04:52.354
我对每一个问题都有答案，有点预装在我的测试框架中，
I have a answer to every question, kinda pre canned in my test framework,

73
00:04:52.354 --> 00:04:56.220
我会查一下我对立方体的答案表。
and I'll just look up my answers table to the cube.

74
00:04:57.220 --> 00:05:00.230
然后发生的事情是我们实际上是
Then what's happening is we're actually

75
00:05:00.230 --> 00:05:05.570
当我提出正确的问题时，写回有效路线。
writing the valid route back when I asked the right questions.

76
00:05:05.570 --> 00:05:10.480
打印应该可以工作，然后很有趣，
Printing should work and then it's interesting,

77
00:05:10.480 --> 00:05:15.450
我们可能没有注意到的是固定数据点是递归数据
something we may not have noticed is the fixed data point is a recursive data

78
00:05:15.450 --> 00:05:17.480
正如我们所见，它的结构刚刚炸毁了这个甲板。
structure as we see it just blew this deck.

79
00:05:17.480 --> 00:05:20.820
我们只是一遍又一遍地调用它，对吗？
We just call this again and again and again right?

80
00:05:20.820 --> 00:05:25.834
停止免费 mon 广告的方法，你有几个构造函数
And the way to stop a free mon ad, you have a few constructors

81
00:05:25.834 --> 00:05:30.566
在这里，电梯 f 把你放在了自由里，但你也有纯洁。
in here lift f puts you in a free, but you also have pure.

82
00:05:30.566 --> 00:05:36.440
而 pure 是一种让你的构造函数结束的方法，它只会停止。
And pure is a way to make your constructor that's the end and it will just stop.

83
00:05:36.440 --> 00:05:40.970
所以我们可以这样做，但我们不会，你知道，它就在那里。
So we could do that, but we wont, you know, it's there.

84
00:05:40.970 --> 00:05:42.860
这是一个很酷的方法。
And this is a cool way to do it.

85
00:05:42.860 --> 00:05:46.110
我们已经编写了一个应用程序，而且我们已经根据免费的 monad 编写了它。
We've written an app and we've written it in terms of free monads.

86
00:05:46.110 --> 00:05:48.440
我们已经制作了多个口译员。
And we've made multiple interpreters.

87
00:05:48.440 --> 00:05:50.020
所以也一样。
So all as well.

88
00:05:50.020 --> 00:05:52.072
好的，我们对此有任何疑问吗？
Okay, do we have any questions on this?

89
00:05:52.072 --> 00:05:53.642
&gt;&gt; 您可以向上滚动到顶部吗？
&gt;&gt; Can you scroll back up to the top?

90
00:05:53.642 --> 00:05:58.710
我确定我只是，它是由我们添加的最后一件事触发的。
I'm sure I just, it was triggered by the one of the last things that we added.

91
00:05:58.710 --> 00:06:04.900
我们必须引入 Id monad。
We had to pull in what was the Id monad.

92
00:06:04.900 --> 00:06:06.900
是的，定点类型。
Yes, the fixed points type.

93
00:06:06.900 --> 00:06:10.172
本质上，我们必须有某种退出条件。
Essentially, we have to have some sort of exit condition.

94
00:06:10.172 --> 00:06:11.360
&gt;&gt; 是的。 &gt;&gt; 循环。
&gt;&gt; Yes. &gt;&gt; The loops.

95
00:06:11.360 --> 00:06:16.840
所以无论是类型还是逻辑结构或
So whether that's a type or it's a logical construction or

96
00:06:16.840 --> 00:06:20.490
一些东西，我们需要有某种方式来提示递归。
something, we need to have some way of cueing the recursion to.

97
00:06:20.490 --> 00:06:22.911
&gt;&gt; 没错，实际上就是这样。
&gt;&gt; Exactly, and actually that's exactly.

98
00:06:22.911 --> 00:06:25.160
所以你从修复开始。
So you start with fix.

99
00:06:26.210 --> 00:06:31.750
我们有这些函子要么有不动点函子，要么没有。
And we have these functors have either have a fixed point functor or you don't.

100
00:06:31.750 --> 00:06:33.185
列表是一个不动点函子，
A list is a fixed point functor,

101
00:06:33.185 --> 00:06:37.190
因为它会在列表中的列表中包含一个列表，直到您点击 null，对吗？
cuz it will have a list inside a list inside a list until you hit null, right?

102
00:06:37.190 --> 00:06:39.383
而 null 是不动点。
And null is the fixed point.

103
00:06:39.383 --> 00:06:43.630
fix 的工作方式是将自己注入到这些东西之间。
The way fix works is it injects itself in between each of these things.

104
00:06:44.870 --> 00:06:49.700
而免费做完全相同的事情只是为您提供纯粹的停止。
And free does the exact same thing just provides you with pure to stop.

105
00:06:49.700 --> 00:06:52.420
所以你有你的函子，然后你去自由你要函子和
So you have your functor and then you go to free you're going to functor and

106
00:06:52.420 --> 00:06:54.960
得到自由，然后你终于达到了你的纯洁，然后你就停下来了。
get free and then you finally hit your pure and you stop.

107
00:06:54.960 --> 00:06:58.580
所以它给你它只是固定的端点。
So it gives you it's just fixed with an endpoint to it.
