WEBVTT

1
00:00:00.030 --> 00:00:06.745
它所做的是通过获取第二个参数并将其传入来取消嵌套。
What it's done is unnested it by taking a second argument and passing it in.

2
00:00:06.745 --> 00:00:10.830
如果这里的第二个参数又高了，对，但是
And if the second argument here is just high again, right, but

3
00:00:10.830 --> 00:00:14.623
这是原来的高，这有点奇怪，对吧？
it's the original high, which is kind of weird, right?

4
00:00:14.623 --> 00:00:19.930
我们给它这个 x，这个 x 处理它并传入转换后的 x。
We gave it this x, and this one processed it and passed in the transformed x.

5
00:00:19.930 --> 00:00:22.460
这个在外面运行原始的x。
This one's running the original x on the outside.

6
00:00:22.460 --> 00:00:26.139
所以我们得到了像 x hat 之类的东西。
So we get this kind of like x hat or something.

7
00:00:26.139 --> 00:00:27.588
就像原来的x。
It's like the original x.

8
00:00:27.588 --> 00:00:30.700
那么我们会得到小写字母的惊叹号吗？
So the exclaim that we would get the lowercase one right?

9
00:00:31.720 --> 00:00:34.025
这样做，因为它是 x 帽子，当然。
Do that up cuz it's x hat, of course.

10
00:00:34.025 --> 00:00:37.657
[笑]让我们回到x。
[LAUGH] let's just go back to x.

11
00:00:37.657 --> 00:00:40.172
所以我们得到了原始的 x。
So we get the original x.

12
00:00:40.172 --> 00:00:44.451
让我们把它放在一个有上一个和那个的数组中，所以
Let's put this in an array that has the upper one and that one, so

13
00:00:44.451 --> 00:00:46.598
我们可以同时看到两者。
we can see both at the same time.

14
00:00:46.598 --> 00:00:48.345
让我把两个都拿来。
Let me get both here.

15
00:00:48.345 --> 00:00:53.248
所以这种行为在前期看起来不是很有用，但它会让我们
So this behavior doesn't seem very useful upfront, but it will allows us

16
00:00:53.248 --> 00:00:58.171
要做的是通过我们的整个程序线程类隐形环境。
to do is thread kind of invisible environment through our whole program.

17
00:00:58.171 --> 00:01:01.576
这就是我们称这个读者的原因，因为 x 没有被转换。
That's why we call this reader, is because x wasn't transformed.

18
00:01:01.576 --> 00:01:05.820
x 只是有点通过，我可以随时访问它。
x is just kinda carried through and I can just gain access to it whenever I want.

19
00:01:05.820 --> 00:01:12.396
所以当我开始转换时，我的输入仍然可以恢复到这种原始状态。
So as I start transforming, my input can still get back to this kind of original.

20
00:01:12.396 --> 00:01:17.594
另一个有趣的事情是我们可以创建一个函数，取 x，然后
Something else that's interesting is we can make a function of, takes x, and

21
00:01:17.594 --> 00:01:22.970
我们将只返回一个接受任何内容的函数，并将 x 放在那里。
we'll just return a function that takes whatever, and just puts the x in there.

22
00:01:24.580 --> 00:01:27.140
所以我们可以从一个Hello函数开始。
So we can start with a function of Hello.

23
00:01:28.600 --> 00:01:30.680
然后我们可以映射到上层。
And then we can map to upper on that.

24
00:01:30.680 --> 00:01:34.423
让我们这样做，这样我们就能得到一些空间。
Let's do this so we can get some room.

25
00:01:34.423 --> 00:01:35.554
现在发生了什么？
What's happening now?

26
00:01:35.554 --> 00:01:38.296
这有点奇怪，对吧？
This is kind of weird, right?

27
00:01:38.296 --> 00:01:41.842
这将是你好或你好。
It's going to be hi or hello.

28
00:01:41.842 --> 00:01:47.940
我们现在有两个参数，我们得到了 Hello 和 hi&#39;，那么这里发生了什么？
We have two arguments now, we got Hello and hi', so what's happening here?

29
00:01:47.940 --> 00:01:53.290
我们从一个函数开始，这里的参数是 x 作为它的结果，
We're starting with a function with the argument here x as its result,

30
00:01:53.290 --> 00:01:55.740
我们将映射过去。
and we're gonna map over that.

31
00:01:55.740 --> 00:01:57.472
我们可以整天映射它。
We can map over it all day long.

32
00:01:57.472 --> 00:02:02.180
我们可以忽略这个嗨的东西，对，这只是大写的tillow。
We can ignore this hi thing, right, this will just be uppercase tillow.

33
00:02:02.180 --> 00:02:04.990
但是如果我们想访问第二个参数，
But if we want to access the second argument,

34
00:02:04.990 --> 00:02:06.280
让我们让它更正式一点。
let's make it a little bit more formal.

35
00:02:06.280 --> 00:02:08.620
假设这是端口 3000，对吗？
Let's say this is the port 3000, right?

36
00:02:08.620 --> 00:02:11.205
如果我想访问我的配置，
If I wanna access my config,

37
00:02:11.205 --> 00:02:16.718
突然之间，我可以在我的函数中创建一个函数。
all of a sudden I can make a function here inside my function.

38
00:02:16.718 --> 00:02:18.980
这给了我配置。
And that gives me the config.

39
00:02:18.980 --> 00:02:25.620
所以让我们展示一下，我们同时拥有了我们的鞋面和我们的配置。
So let's just show, we've got our upper and our config at the same time.

40
00:02:27.700 --> 00:02:31.900
太好了，我们正在凭空捏造东西，然后
Sweet, we're pulling stuff out of thin air, and

41
00:02:31.900 --> 00:02:36.300
通常你会看到这样的框架，
typically you'll see this kind of framed this way,

42
00:02:36.300 --> 00:02:39.904
我们有一个函数运行。
where we have a function running through.

43
00:02:39.904 --> 00:02:42.950
然后在这个应用程序中间的某个地方，我只想获取我的配置和
And then somewhere in the middle of this this app, I just wanna grab my config and

44
00:02:42.950 --> 00:02:44.141
它无处不在。
there it comes out of nowhere.

45
00:02:44.141 --> 00:02:46.580
我不知道它是如何工作的，这太神奇了。
I don't know how that works, it's amazing.

46
00:02:46.580 --> 00:02:51.489
所以让我们再做一个函数，让它更方便一点。
So let's make one more function to make this a little bit more convenient.

47
00:02:51.489 --> 00:02:55.030
我们会说 Fn.ask。
And we'll say Fn.ask.

48
00:02:55.030 --> 00:03:00.283
而 Fn.ask 已经是一个函数，它说，
And Fn.ask is just already a function that says,

49
00:03:00.283 --> 00:03:06.421
好吧，我会把我手里的东西都给你。
okay, I'm going to just give you whatever I'm holding.

50
00:03:06.421 --> 00:03:08.300
就像配置到配置一样，对吧？
Just like config to config, right?

51
00:03:09.870 --> 00:03:14.020
所以这是一个方便的函数，而不是这个奇怪的函数
So this is a convenience function that says instead of this bizarre function

52
00:03:14.020 --> 00:03:17.950
在我的东西中间的构造函数，我可以说，
constructor in the middle of my stuff, I'm able to say,

53
00:03:19.610 --> 00:03:22.700
问，然后我把我的配置拿出来。
ask, and then I get my config out.

54
00:03:23.760 --> 00:03:28.280
我可以同时在配置中返回上层。
And I can return upper in config at the same time.

55
00:03:28.280 --> 00:03:32.050
请注意我们正在执行链，对，因为 ask 是另一个函数。
And notice we're doing chain, right, because ask is another function.

56
00:03:32.050 --> 00:03:36.253
然后我们可以用 config 运行它，然后我们就炸了，明白吗？
And then we can run it with config and and we blow up, see?

57
00:03:36.253 --> 00:03:36.795
完毕。
Done.

58
00:03:36.795 --> 00:03:40.750
[笑] 不，这里发生了什么？
[LAUGH] No, what's happening here?

59
00:03:40.750 --> 00:03:42.934
ask 没有定义，它是 Fn.ask。
ask is not defined, it's Fn.ask.

60
00:03:42.934 --> 00:03:46.010
我们去那里，我们去。
There we go and there we go.

61
00:03:46.010 --> 00:03:47.600
这是读者单子。
This is the reader monad.

62
00:03:47.600 --> 00:03:51.290
它在功能架构中非常有用。
It's insanely helpful during function architecture.

63
00:03:51.290 --> 00:03:56.644
最近，图书馆开始更多地研究 Zio 或 Rio 的签名。
Lately, libraries have started to work way more on this signature of Zio or Rio.

64
00:03:56.644 --> 00:04:00.113
这个想法是你可以在这里进行依赖注入。
The idea is that you can do dependency injection in here.

65
00:04:00.113 --> 00:04:02.919
我不仅可以拥有我的配置，还可以拥有
I could have not just my configuration but

66
00:04:02.919 --> 00:04:06.053
我所有的依赖项，比如我的数据库连接。
all of my dependencies like my db connection.

67
00:04:06.053 --> 00:04:10.930
无论我想在本地存储中使用什么策略
And whatever my strategy for whatever I wanna use in my local storage or

68
00:04:10.930 --> 00:04:14.745
无论如何，然后我就可以摆脱我的环境了。
whatever, and then I can just get my environment out.

69
00:04:14.745 --> 00:04:16.330
现在我有了我所有的效果。
And now I have all my my effects.

70
00:04:16.330 --> 00:04:19.490
我只是不知从哪里通过了那些。
I've just kind of passed in those out of nowhere.

71
00:04:20.630 --> 00:04:26.860
所以这是我们可以使用的非常有用的技术，但那是读者。
So this is a really useful technique that we can use, but that's reader.

72
00:04:26.860 --> 00:04:28.226
超酷。
Super cool.

73
00:04:28.226 --> 00:04:31.690
我不打算谈论状态，但状态正是这样。
I'm not gonna talk about state, but state is exactly this.

74
00:04:31.690 --> 00:04:34.770
这就像完全一样的东西，除了我们能够通过一个状态并
It's like the same exact thing, except we're able to thread a state through and

75
00:04:34.770 --> 00:04:36.480
修改它。
modify it.

76
00:04:36.480 --> 00:04:39.472
而这个不允许你修改它。
And this one doesn't let you modify it.

77
00:04:39.472 --> 00:04:43.990
我只是觉得它在 JavaScript 中不像其他人那样有用。
I just don't find it as useful maybe in JavaScript as others do.

78
00:04:43.990 --> 00:04:45.710
但我们可以稍后再谈。
But we can talk about that later.
